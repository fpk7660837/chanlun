//@version=6
indicator('缠论自动画笔中枢 (Chanlun Pro)', '缠论笔中枢', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// ============================================================================
// 缠论系统 - 基于chan-theory.md理论文档完整实现
// ============================================================================
// 计算流程：原始K线 → K线合并 → 分型识别 → 笔 → 线段 → 特征序列 → 中枢 → 买卖点
// ============================================================================

// === 用户参数 ===
bi_strict = input.bool(true, title = '严格模式', tooltip = '笔至少需要4根合并K线')
bi_fx_check = input.string('strict', title = '分型校验', options = ['strict', 'normal'], tooltip = 'strict=严格校验分型高低点关系')
bi_end_is_peak = input.bool(true, title = '笔端点必须是极值', tooltip = '笔的结束点必须是笔内的最高/最低点')
seg_algo = input.string('normal', title = '线段算法', options = ['normal', 'simple'], tooltip = 'normal=标准线段(特征序列), simple=简化线段')
zs_algo = input.string('normal', title = '中枢算法', options = ['normal', 'simple'], tooltip = 'normal=基于特征序列, simple=基于连续笔')
zs_need_combine = input.bool(true, title = '中枢合并', tooltip = '相邻中枢有重叠时合并')
zs_combine_mode = input.string('zs', title = '合并模式', options = ['zs', 'peak'], tooltip = 'zs=按中枢区间合并, peak=按极值合并')
bsp_enabled = input.bool(true, title = '启用买卖点')
bsp_types = input.string('1,1p,2,3a,3b', title = '买卖点类型', tooltip = '1=一类, 1p=盘整一类, 2=二类, 3a=三类A, 3b=三类B')
bsp1_only_multibi_zs = input.bool(true, title = '一类仅多笔中枢', tooltip = '一类买卖点只考虑多笔中枢')
bsp2_follow_1 = input.bool(true, title = '二类跟随一类', tooltip = '二类买卖点必须跟随一类')
bsp3_follow_1 = input.bool(true, title = '三类跟随一类', tooltip = '三类买卖点必须跟随一类')
max_bs2_rate = input.float(0.9999, title = '二类最大回撤', minval = 0.1, maxval = 1.0, step = 0.01)
divergence_rate = input.float(1.0, title = '背驰阈值', minval = 0.1, maxval = 2.0, step = 0.1, tooltip = '1.0表示不限制背驰比例')
macd_algo = input.string('peak', title = 'MACD算法', options = ['peak', 'area'], tooltip = 'peak=峰值法, area=面积法')
macd_fast = input.int(12, title = 'MACD快线', minval = 1)
macd_slow = input.int(26, title = 'MACD慢线', minval = 1)
macd_signal = input.int(9, title = 'MACD信号线', minval = 1)
show_bi = input.bool(true, title = '显示笔')
show_seg = input.bool(true, title = '显示线段')
show_zs = input.bool(true, title = '显示中枢')
show_bsp = input.bool(true, title = '显示买卖点')
show_fx_label = input.bool(false, title = '显示分型标签')

// === 颜色定义 ===
BI_UP_COLOR = color.new(color.red, 0)
BI_DOWN_COLOR = color.new(color.green, 0)
SEG_UP_COLOR = color.new(color.orange, 0)
SEG_DOWN_COLOR = color.new(color.teal, 0)
ZS_COLOR = color.new(color.blue, 80)
ZS_BORDER_COLOR = color.new(color.blue, 0)
BUY1_COLOR = color.new(color.fuchsia, 0)
SELL1_COLOR = color.new(color.maroon, 0)
BUY2_COLOR = color.new(color.yellow, 0)
SELL2_COLOR = color.new(color.gray, 0)
BUY3_COLOR = color.new(color.lime, 0)
SELL3_COLOR = color.new(color.silver, 0)

// === MACD计算 ===
[macd_line, signal_line, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)

// ============================================================================
// 数据结构定义
// ============================================================================
type KLine
    float high
    float low
    int time_start
    int time_end
    int bar_start
    int bar_end
    int idx
    int dir

type FX
    int idx
    int type
    float price
    float fx_high
    float fx_low
    int kl_idx
    int time
    int bar_idx
    label lbl

type Bi
    int idx
    int dir
    int start_fx_idx
    int end_fx_idx
    float high
    float low
    int start_time
    int end_time
    int start_bar
    int end_bar
    bool is_sure
    int seg_idx
    float macd_metric
    line ln

type Seg
    int idx
    int dir
    int start_bi_idx
    int end_bi_idx
    float high
    float low
    int start_time
    int end_time
    bool is_sure
    line ln

type ZS
    int idx
    float zg
    float zd
    float gg
    float dd
    int begin_bi_idx
    int end_bi_idx
    int bi_in_idx
    int bi_out_idx
    int seg_idx
    int start_time
    int end_time
    box bx
    bool is_sure

type BSP
    int type
    int bi_idx
    int zs_idx
    float price
    int time
    int bar_idx
    int relate_bsp1_idx
    float divergence
    label lbl

// ============================================================================
// 全局变量
// ============================================================================
var klines = array.new<KLine>()
var fractals = array.new<FX>()
var bis = array.new<Bi>()
var segs = array.new<Seg>()
var zss = array.new<ZS>()
var bsps = array.new<BSP>()
var macd_history = array.new<float>()
var bi_lines = array.new<line>()  // 保存笔线对象，防止被垃圾回收

var float kl_high = na
var float kl_low = na
var int kl_time_start = na
var int kl_time_end = na
var int kl_bar_start = na
var int kl_bar_end = na
var bool kl_initialized = false

// ============================================================================
// 辅助函数 (纯函数，不修改全局变量)
// ============================================================================
safe_delete_line(ln) =>
    if not na(ln)
        line.delete(ln)

safe_delete_box(bx) =>
    if not na(bx)
        box.delete(bx)

safe_delete_label(lbl) =>
    if not na(lbl)
        label.delete(lbl)

bi_amp(Bi bi) =>
    math.abs(bi.high - bi.low)

has_overlap(low1, high1, low2, high2) =>
    not (high1 < low2 or high2 < low1)

check_include(h1, l1, h2, l2) =>
    (h1 >= h2 and l1 <= l2) or (h2 >= h1 and l2 <= l1)

is_bsp_type_enabled(bsp_type_str) =>
    str.contains(bsp_types, bsp_type_str)

calc_macd_metric_peak(start_bar, end_bar, dir) =>
    float peak_val = 0.0
    int arr_size = array.size(macd_history)
    if arr_size > 0 and start_bar <= end_bar
        // 将bar_index转换为数组索引
        int offset = bar_index - arr_size + 1
        int idx_start = math.max(0, start_bar - offset)
        int idx_end = math.min(arr_size - 1, end_bar - offset)
        if idx_start >= 0 and idx_end >= idx_start and idx_end < arr_size
            for i = idx_start to idx_end
                float hist_val = array.get(macd_history, i)
                if dir == 1
                    if hist_val > peak_val
                        peak_val := hist_val
                else
                    if hist_val < 0 and math.abs(hist_val) > peak_val
                        peak_val := math.abs(hist_val)
    peak_val

calc_macd_metric_area(start_bar, end_bar, dir) =>
    float area = 0.0
    int arr_size = array.size(macd_history)
    if arr_size > 0 and start_bar <= end_bar
        int offset = bar_index - arr_size + 1
        int idx_start = math.max(0, start_bar - offset)
        int idx_end = math.min(arr_size - 1, end_bar - offset)
        if idx_start >= 0 and idx_end >= idx_start and idx_end < arr_size
            for i = idx_start to idx_end
                float hist_val = array.get(macd_history, i)
                if dir == 1 and hist_val > 0
                    area += hist_val
                else if dir == -1 and hist_val < 0
                    area += math.abs(hist_val)
    area

calc_bi_macd(Bi bi) =>
    if macd_algo == 'peak'
        calc_macd_metric_peak(bi.start_bar, bi.end_bar, bi.dir)
    else
        calc_macd_metric_area(bi.start_bar, bi.end_bar, bi.dir)

check_bi_span(start_kl_idx, end_kl_idx) =>
    int span = end_kl_idx - start_kl_idx
    // span是索引差值，实际K线数量 = span + 1
    // bi_strict模式：至少4根K线，即span >= 3
    // 非strict模式：至少3根K线，即span >= 2
    bi_strict ? span >= 3 : span >= 2

check_fx_valid(FX start_fx, FX end_fx) =>
    if bi_fx_check == 'strict'
        // 和老代码的"严格笔"逻辑一致：
        // 当前分型的中间K线不能和前一个分型的三K线范围重叠
        if start_fx.type == 1 and end_fx.type == -1
            // 顶分型 -> 底分型：底分型的中间K线高点 < 顶分型的三K线最低点
            end_fx.price < start_fx.fx_low
        else if start_fx.type == -1 and end_fx.type == 1
            // 底分型 -> 顶分型：顶分型的中间K线低点 > 底分型的三K线最高点
            end_fx.price > start_fx.fx_high
        else
            false
    else
        true

check_bi_end_peak(start_kl_idx, end_kl_idx, is_up) =>
    if not bi_end_is_peak
        true
    else
        bool is_peak = true
        if end_kl_idx > start_kl_idx and end_kl_idx < array.size(klines)
            end_kl = array.get(klines, end_kl_idx)
            float cmp_val = is_up ? end_kl.high : end_kl.low
            for i = start_kl_idx + 1 to end_kl_idx - 1
                if i < array.size(klines)
                    kl = array.get(klines, i)
                    if is_up and kl.high > cmp_val
                        is_peak := false
                        break
                    if not is_up and kl.low < cmp_val
                        is_peak := false
                        break
        is_peak

// ============================================================================
// 存储MACD历史
// ============================================================================
array.push(macd_history, macd_hist)
if array.size(macd_history) > 2000
    array.shift(macd_history)

// ============================================================================
// K线合并处理 (主作用域)
// ============================================================================
if not kl_initialized
    kl_high := high
    kl_low := low
    kl_time_start := time
    kl_time_end := time
    kl_bar_start := bar_index
    kl_bar_end := bar_index
    kl_initialized := true
else
    bool has_inc = check_include(kl_high, kl_low, high, low)
    
    if has_inc
        int prev_dir = 0
        if array.size(klines) >= 1
            prev_kl = array.last(klines)
            // 修正：根据前一根K线的方向来判断
            prev_dir := prev_kl.dir
            // 如果前一根K线方向未设置，通过比较高低点来判断
            if prev_dir == 0
                prev_dir := (kl_high > prev_kl.high) ? 1 : -1
        else
            // 第一根K线时，通过比较当前bar的开盘和收盘判断
            prev_dir := close >= open ? 1 : -1
        
        if prev_dir == 1
            kl_high := math.max(kl_high, high)
            kl_low := math.max(kl_low, low)
        else
            kl_high := math.min(kl_high, high)
            kl_low := math.min(kl_low, low)
        kl_time_end := time
        kl_bar_end := bar_index
    else
        // 确定方向：当前K线相对于前一根的方向
        int kl_dir = 0
        if array.size(klines) > 0
            prev_kl = array.last(klines)
            kl_dir := (kl_high > prev_kl.high) ? 1 : -1
        
        new_kl = KLine.new(kl_high, kl_low, kl_time_start, kl_time_end, kl_bar_start, kl_bar_end, array.size(klines), kl_dir)
        array.push(klines, new_kl)
        kl_high := high
        kl_low := low
        kl_time_start := time
        kl_time_end := time
        kl_bar_start := bar_index
        kl_bar_end := bar_index

// 限制K线数量
if array.size(klines) > 2000
    array.shift(klines)

// 限制笔线数量（避免超出TradingView限制）
// 保留最近的300笔，删除更早的
while array.size(bi_lines) > 300
    old_line = array.shift(bi_lines)
    line.delete(old_line)

// ============================================================================
// 分型识别 (主作用域)
// ============================================================================
var bool fx_detected = false
var FX new_fx = na

fx_detected := false
int kl_count = array.size(klines)

// 检测分型：需要至少3根K线
if kl_count >= 3
    k1 = array.get(klines, kl_count - 3)
    k2 = array.get(klines, kl_count - 2)
    k3 = array.get(klines, kl_count - 1)
    
    // 严格的分型定义（和老代码一致）
    bool is_top = k2.high > k1.high and k2.high > k3.high and k2.low > k1.low and k2.low > k3.low
    bool is_bot = k2.low < k1.low and k2.low < k3.low and k2.high < k1.high and k2.high < k3.high
    
    if is_top or is_bot
        int fx_type = is_top ? 1 : -1
        float fx_price = is_top ? k2.high : k2.low
        float fx_high = math.max(k1.high, math.max(k2.high, k3.high))
        float fx_low = math.min(k1.low, math.min(k2.low, k3.low))
        
        // 检查是否是新的分型（避免重复添加）
        bool is_new_fx = true
        if array.size(fractals) > 0
            last_fx = array.last(fractals)
            // 如果分型的K线索引相同，说明是同一个分型
            if last_fx.kl_idx == k2.idx
                is_new_fx := false
        
        if is_new_fx
            label lbl = na
            if show_fx_label
                lbl := label.new(k2.time_end, fx_price, is_top ? '顶' : '底',
                     xloc = xloc.bar_time, color = is_top ? color.red : color.green, textcolor = color.white,
                     size = size.tiny,
                     style = is_top ? label.style_label_down : label.style_label_up)
            
            new_fx := FX.new(array.size(fractals), fx_type, fx_price, fx_high, fx_low, k2.idx, k2.time_end, k2.bar_end, lbl)
            fx_detected := true


// ============================================================================
// 笔的识别 (主作用域) - 只计算数据，不绑定
// ============================================================================
if fx_detected and not na(new_fx)
    if array.size(fractals) == 0
        array.push(fractals, new_fx)
    else
        last_fx = array.last(fractals)
        
        if new_fx.type != last_fx.type
            bool span_ok = check_bi_span(last_fx.kl_idx, new_fx.kl_idx)
            bool fx_ok = check_fx_valid(last_fx, new_fx)
            bool is_up = new_fx.type == 1
            bool peak_ok = check_bi_end_peak(last_fx.kl_idx, new_fx.kl_idx, is_up)
            
            if span_ok and fx_ok and peak_ok
                array.push(fractals, new_fx)
                
                int bi_dir = new_fx.type
                float bi_high = math.max(last_fx.price, new_fx.price)
                float bi_low = math.min(last_fx.price, new_fx.price)
                
                if array.size(bis) > 0
                    prev_bi = array.last(bis)
                    prev_bi.is_sure := true
                    // 将前一笔的线改为实线
                    if not na(prev_bi.ln)
                        line.set_style(prev_bi.ln, line.style_solid)
                
                // 立即绘制笔线（和老代码一样）
                line ln = na
                if show_bi
                    ln := line.new(last_fx.time, bi_dir == 1 ? bi_low : bi_high,
                         new_fx.time, bi_dir == 1 ? bi_high : bi_low,
                         xloc = xloc.bar_time,
                         color = bi_dir == 1 ? BI_UP_COLOR : BI_DOWN_COLOR,
                         width = 2,
                         style = line.style_dashed)
                    array.push(bi_lines, ln)  // 存储到全局数组防止被垃圾回收
                
                new_bi = Bi.new(array.size(bis), bi_dir, array.size(fractals) - 2,
                     array.size(fractals) - 1, bi_high, bi_low, last_fx.time, new_fx.time,
                     last_fx.bar_idx, new_fx.bar_idx, false, -1, 0.0, ln)
                new_bi.macd_metric := calc_bi_macd(new_bi)
                array.push(bis, new_bi)
        else
            bool should_extend = false
            if new_fx.type == 1
                should_extend := new_fx.price > last_fx.price
            else
                should_extend := new_fx.price < last_fx.price
            
            if should_extend
                safe_delete_label(last_fx.lbl)
                array.pop(fractals)
                
                if array.size(bis) > 0
                    last_bi = array.pop(bis)
                    // 删除旧的笔线
                    safe_delete_line(last_bi.ln)
                    // 从数组中移除
                    if array.size(bi_lines) > 0
                        array.pop(bi_lines)
                    // 恢复前一笔的状态
                    if array.size(bis) > 0
                        prev_bi = array.last(bis)
                        prev_bi.is_sure := false
                        // 将前一笔改回虚线
                        if not na(prev_bi.ln)
                            line.set_style(prev_bi.ln, line.style_dashed)
                
                array.push(fractals, new_fx)
                
                if array.size(fractals) >= 2
                    prev_fx = array.get(fractals, array.size(fractals) - 2)
                    int bi_dir = new_fx.type
                    float bi_high = math.max(prev_fx.price, new_fx.price)
                    float bi_low = math.min(prev_fx.price, new_fx.price)
                    
                    // 立即绘制笔线
                    line ln = na
                    if show_bi
                        ln := line.new(prev_fx.time, bi_dir == 1 ? bi_low : bi_high,
                             new_fx.time, bi_dir == 1 ? bi_high : bi_low,
                             xloc = xloc.bar_time,
                             color = bi_dir == 1 ? BI_UP_COLOR : BI_DOWN_COLOR,
                             width = 2,
                             style = line.style_dashed)
                        array.push(bi_lines, ln)  // 存储到全局数组防止被垃圾回收
                    
                    new_bi = Bi.new(array.size(bis), bi_dir, array.size(fractals) - 2,
                         array.size(fractals) - 1, bi_high, bi_low, prev_fx.time, new_fx.time,
                         prev_fx.bar_idx, new_fx.bar_idx, false, -1, 0.0, ln)
                    new_bi.macd_metric := calc_bi_macd(new_bi)
                    array.push(bis, new_bi)

// ============================================================================
// 最后一根K线：绑定所有图形对象
// ============================================================================
if barstate.islast
    // 确认最后一笔
    if array.size(bis) > 0
        last_bi = array.last(bis)
        if not last_bi.is_sure
            last_bi.is_sure := true
            // 将最后一笔改为实线
            if not na(last_bi.ln)
                line.set_style(last_bi.ln, line.style_solid)
    
    // ========== 清理旧的线段 ==========
    if array.size(segs) > 0
        for i = 0 to array.size(segs) - 1
            seg = array.get(segs, i)
            safe_delete_line(seg.ln)
        array.clear(segs)
    
    // ========== 构建线段 ==========
    int bi_count = array.size(bis)
    // 只处理最近的笔以提高性能和避免对象数量限制
    int max_bi_to_process = 150
    int bi_start_idx = math.max(0, bi_count - max_bi_to_process)
    
    if bi_count >= 3
        if seg_algo == 'simple'
            // 简化线段算法
            int seg_start = bi_start_idx
            int current_dir = array.get(bis, bi_start_idx).dir
            float seg_high = array.get(bis, bi_start_idx).high
            float seg_low = array.get(bis, bi_start_idx).low
            
            int i = 1
            while i < bi_count
                bi = array.get(bis, i)
                seg_high := math.max(seg_high, bi.high)
                seg_low := math.min(seg_low, bi.low)
                
                bool should_end = false
                if i >= seg_start + 2
                    start_bi = array.get(bis, seg_start)
                    if current_dir == 1
                        if bi.low < start_bi.low
                            should_end := true
                    else
                        if bi.high > start_bi.high
                            should_end := true
                
                if should_end and i > seg_start + 1
                    start_bi = array.get(bis, seg_start)
                    end_bi = array.get(bis, i - 1)
                    
                    line ln = na
                    if show_seg
                        float start_price = current_dir == 1 ? start_bi.low : start_bi.high
                        float end_price = current_dir == 1 ? end_bi.high : end_bi.low
                        ln := line.new(start_bi.start_time, start_price, end_bi.end_time, end_price,
                             xloc = xloc.bar_time, color = current_dir == 1 ? SEG_UP_COLOR : SEG_DOWN_COLOR,
                             width = 3, style = line.style_solid)
                    
                    new_seg = Seg.new(array.size(segs), current_dir, seg_start, i - 1,
                         seg_high, seg_low, start_bi.start_time, end_bi.end_time, true, ln)
                    
                    for j = seg_start to i - 1
                        bi_to_update = array.get(bis, j)
                        bi_to_update.seg_idx := new_seg.idx
                    
                    array.push(segs, new_seg)
                    seg_start := i - 1
                    current_dir := -current_dir
                    seg_high := bi.high
                    seg_low := bi.low
                
                i := i + 1
            
            // 最后一个未完成的线段
            if seg_start < bi_count - 1
                start_bi = array.get(bis, seg_start)
                end_bi = array.get(bis, bi_count - 1)
                
                float final_seg_high = start_bi.high
                float final_seg_low = start_bi.low
                for j = seg_start to bi_count - 1
                    bi = array.get(bis, j)
                    final_seg_high := math.max(final_seg_high, bi.high)
                    final_seg_low := math.min(final_seg_low, bi.low)
                
                line ln = na
                if show_seg
                    float start_price = current_dir == 1 ? start_bi.low : start_bi.high
                    float end_price = current_dir == 1 ? end_bi.high : end_bi.low
                    ln := line.new(start_bi.start_time, start_price, end_bi.end_time, end_price,
                         xloc = xloc.bar_time, color = current_dir == 1 ? SEG_UP_COLOR : SEG_DOWN_COLOR,
                         width = 3, style = line.style_dashed)
                
                new_seg = Seg.new(array.size(segs), current_dir, seg_start, bi_count - 1,
                     final_seg_high, final_seg_low, start_bi.start_time, end_bi.end_time, false, ln)
                
                for j = seg_start to bi_count - 1
                    bi_to_update = array.get(bis, j)
                    bi_to_update.seg_idx := new_seg.idx
                
                array.push(segs, new_seg)
        else
            // 标准线段算法 (基于特征序列分型)
            int seg_start = bi_start_idx
            int current_dir = array.get(bis, bi_start_idx).dir
            
            int i = 2
            while i < bi_count
                // 提取特征序列
                feature_highs = array.new<float>()
                feature_lows = array.new<float>()
                feature_bi_idxs = array.new<int>()
                
                for j = seg_start to i
                    bi = array.get(bis, j)
                    if bi.dir != current_dir
                        array.push(feature_highs, bi.high)
                        array.push(feature_lows, bi.low)
                        array.push(feature_bi_idxs, j)
                
                // 检查特征序列是否形成分型
                bool has_fractal = false
                int fractal_bi_idx = -1
                int seq_size = array.size(feature_highs)
                
                if seq_size >= 3
                    float h1 = array.get(feature_highs, seq_size - 3)
                    float h2 = array.get(feature_highs, seq_size - 2)
                    float h3 = array.get(feature_highs, seq_size - 1)
                    float l1 = array.get(feature_lows, seq_size - 3)
                    float l2 = array.get(feature_lows, seq_size - 2)
                    float l3 = array.get(feature_lows, seq_size - 1)
                    
                    if current_dir == 1
                        // 向上线段，检查底分型
                        if l2 <= l1 and l2 <= l3 and h2 <= h1 and h2 <= h3
                            has_fractal := true
                            fractal_bi_idx := array.get(feature_bi_idxs, seq_size - 2)
                    else
                        // 向下线段，检查顶分型
                        if h2 >= h1 and h2 >= h3 and l2 >= l1 and l2 >= l3
                            has_fractal := true
                            fractal_bi_idx := array.get(feature_bi_idxs, seq_size - 2)
                
                if has_fractal and fractal_bi_idx > seg_start
                    start_bi = array.get(bis, seg_start)
                    end_bi = array.get(bis, fractal_bi_idx)
                    
                    float seg_high = start_bi.high
                    float seg_low = start_bi.low
                    for j = seg_start to fractal_bi_idx
                        bi = array.get(bis, j)
                        seg_high := math.max(seg_high, bi.high)
                        seg_low := math.min(seg_low, bi.low)
                    
                    line ln = na
                    if show_seg
                        float start_price = current_dir == 1 ? start_bi.low : start_bi.high
                        float end_price = current_dir == 1 ? end_bi.high : end_bi.low
                        ln := line.new(start_bi.start_time, start_price, end_bi.end_time, end_price,
                             xloc = xloc.bar_time, color = current_dir == 1 ? SEG_UP_COLOR : SEG_DOWN_COLOR,
                             width = 3, style = line.style_solid)
                    
                    new_seg = Seg.new(array.size(segs), current_dir, seg_start, fractal_bi_idx,
                         seg_high, seg_low, start_bi.start_time, end_bi.end_time, true, ln)
                    
                    for j = seg_start to fractal_bi_idx
                        bi_to_update = array.get(bis, j)
                        bi_to_update.seg_idx := new_seg.idx
                    
                    array.push(segs, new_seg)
                    seg_start := fractal_bi_idx
                    current_dir := -current_dir
                    i := fractal_bi_idx + 2
                else
                    i := i + 1
            
            // 最后一个未完成的线段
            if seg_start < bi_count - 1
                start_bi = array.get(bis, seg_start)
                end_bi = array.get(bis, bi_count - 1)
                
                float seg_high = start_bi.high
                float seg_low = start_bi.low
                for j = seg_start to bi_count - 1
                    bi = array.get(bis, j)
                    seg_high := math.max(seg_high, bi.high)
                    seg_low := math.min(seg_low, bi.low)
                
                line ln = na
                if show_seg
                    float start_price = current_dir == 1 ? start_bi.low : start_bi.high
                    float end_price = current_dir == 1 ? end_bi.high : end_bi.low
                    ln := line.new(start_bi.start_time, start_price, end_bi.end_time, end_price,
                         xloc = xloc.bar_time, color = current_dir == 1 ? SEG_UP_COLOR : SEG_DOWN_COLOR,
                         width = 3, style = line.style_dashed)
                
                new_seg = Seg.new(array.size(segs), current_dir, seg_start, bi_count - 1,
                     seg_high, seg_low, start_bi.start_time, end_bi.end_time, false, ln)
                
                for j = seg_start to bi_count - 1
                    bi_to_update = array.get(bis, j)
                    bi_to_update.seg_idx := new_seg.idx
                
                array.push(segs, new_seg)


    // ========== 清理旧的中枢 ==========
    if array.size(zss) > 0
        for i = 0 to array.size(zss) - 1
            zs = array.get(zss, i)
            safe_delete_box(zs.bx)
        array.clear(zss)
    
    // ========== 构建中枢 ==========
    int seg_count = array.size(segs)
    
    if zs_algo == 'normal' and seg_count > 0
        // 基于线段和特征序列构建中枢
        for seg_i = 0 to seg_count - 1
            seg = array.get(segs, seg_i)
            
            if seg.end_bi_idx - seg.start_bi_idx >= 2
                // 提取特征序列（与线段方向相反的笔）
                feature_bis = array.new<int>()
                for bi_i = seg.start_bi_idx to seg.end_bi_idx
                    bi = array.get(bis, bi_i)
                    if bi.dir != seg.dir
                        array.push(feature_bis, bi_i)
                
                int feature_count = array.size(feature_bis)
                if feature_count >= 2
                    int start_idx = 0
                    
                    while start_idx <= feature_count - 2
                        int bi_idx1 = array.get(feature_bis, start_idx)
                        int bi_idx2 = array.get(feature_bis, start_idx + 1)
                        
                        bi1 = array.get(bis, bi_idx1)
                        bi2 = array.get(bis, bi_idx2)
                        
                        // 计算重叠区间: zd = max(各笔低点), zg = min(各笔高点)
                        float zd = math.max(bi1.low, bi2.low)
                        float zg = math.min(bi1.high, bi2.high)
                        
                        if zd < zg
                            float gg = math.max(bi1.high, bi2.high)
                            float dd = math.min(bi1.low, bi2.low)
                            int end_feature_idx = start_idx + 1
                            
                            // 尝试延伸中枢
                            if start_idx + 2 < feature_count
                                for j = start_idx + 2 to feature_count - 1
                                    int bi_idx_ext = array.get(feature_bis, j)
                                    bi_ext = array.get(bis, bi_idx_ext)
                                    
                                    if has_overlap(zd, zg, bi_ext.low, bi_ext.high)
                                        float new_zd = math.max(zd, bi_ext.low)
                                        float new_zg = math.min(zg, bi_ext.high)
                                        
                                        if new_zd < new_zg
                                            zd := new_zd
                                            zg := new_zg
                                            gg := math.max(gg, bi_ext.high)
                                            dd := math.min(dd, bi_ext.low)
                                            end_feature_idx := j
                                        else
                                            break
                                    else
                                        break
                            
                            int begin_bi = array.get(feature_bis, start_idx)
                            int end_bi = array.get(feature_bis, end_feature_idx)
                            int bi_in = begin_bi > 0 ? begin_bi - 1 : na
                            int bi_out = end_bi + 1 < array.size(bis) ? end_bi + 1 : na
                            
                            first_bi = array.get(bis, begin_bi)
                            last_bi = array.get(bis, end_bi)
                            
                            box bx = na
                            if show_zs
                                bx := box.new(first_bi.start_time, zg, last_bi.end_time, zd,
                                     xloc = xloc.bar_time, bgcolor = ZS_COLOR, border_color = ZS_BORDER_COLOR,
                                     border_width = 1)
                            
                            new_zs = ZS.new(array.size(zss), zg, zd, gg, dd, begin_bi, end_bi,
                                 bi_in, bi_out, seg.idx, first_bi.start_time, last_bi.end_time,
                                 bx, not na(bi_out))
                            
                            array.push(zss, new_zs)
                            start_idx := end_feature_idx + 1
                        else
                            start_idx := start_idx + 1
    else
        // 简化中枢算法（基于连续笔）
        if bi_count >= 3
            int i = 0
            while i <= bi_count - 3
                bi1 = array.get(bis, i)
                bi2 = array.get(bis, i + 1)
                bi3 = array.get(bis, i + 2)
                
                float zd = math.max(bi1.low, math.max(bi2.low, bi3.low))
                float zg = math.min(bi1.high, math.min(bi2.high, bi3.high))
                
                if zd < zg
                    float gg = math.max(bi1.high, math.max(bi2.high, bi3.high))
                    float dd = math.min(bi1.low, math.min(bi2.low, bi3.low))
                    int end_idx = i + 2
                    
                    // 尝试延伸
                    if i + 3 < bi_count
                        for j = i + 3 to bi_count - 1
                            bi = array.get(bis, j)
                            if has_overlap(zd, zg, bi.low, bi.high)
                                float new_zd = math.max(zd, bi.low)
                                float new_zg = math.min(zg, bi.high)
                                if new_zd < new_zg
                                    zd := new_zd
                                    zg := new_zg
                                    gg := math.max(gg, bi.high)
                                    dd := math.min(dd, bi.low)
                                    end_idx := j
                                else
                                    break
                            else
                                break
                    
                    int bi_in = i > 0 ? i - 1 : na
                    int bi_out = end_idx + 1 < bi_count ? end_idx + 1 : na
                    int seg_idx = bi1.seg_idx
                    
                    box bx = na
                    if show_zs
                        bx := box.new(bi1.start_time, zg, array.get(bis, end_idx).end_time, zd,
                             xloc = xloc.bar_time, bgcolor = ZS_COLOR, border_color = ZS_BORDER_COLOR,
                             border_width = 1)
                    
                    new_zs = ZS.new(array.size(zss), zg, zd, gg, dd, i, end_idx,
                         bi_in, bi_out, seg_idx, bi1.start_time, array.get(bis, end_idx).end_time,
                         bx, not na(bi_out))
                    
                    array.push(zss, new_zs)
                    i := end_idx + 1
                else
                    i := i + 1
    
    // 中枢合并
    if zs_need_combine and array.size(zss) >= 2
        int zs_idx = 0
        while zs_idx < array.size(zss) - 1
            zs1 = array.get(zss, zs_idx)
            zs2 = array.get(zss, zs_idx + 1)
            
            bool same_seg = zs1.seg_idx == zs2.seg_idx or zs1.seg_idx == -1 or zs2.seg_idx == -1
            bool has_zs_overlap = has_overlap(zs1.zd, zs1.zg, zs2.zd, zs2.zg)
            
            if same_seg and has_zs_overlap
                if zs_combine_mode == 'zs'
                    zs1.zd := math.min(zs1.zd, zs2.zd)
                    zs1.zg := math.max(zs1.zg, zs2.zg)
                else
                    zs1.zd := math.min(zs1.dd, zs2.dd)
                    zs1.zg := math.max(zs1.gg, zs2.gg)
                
                zs1.gg := math.max(zs1.gg, zs2.gg)
                zs1.dd := math.min(zs1.dd, zs2.dd)
                zs1.end_bi_idx := zs2.end_bi_idx
                zs1.bi_out_idx := zs2.bi_out_idx
                zs1.end_time := zs2.end_time
                zs1.is_sure := zs2.is_sure
                
                safe_delete_box(zs2.bx)
                array.remove(zss, zs_idx + 1)
                
                safe_delete_box(zs1.bx)
                if show_zs
                    // 用笔的时间来绘制
                    begin_bi_for_box = array.get(bis, zs1.begin_bi_idx)
                    end_bi_for_box = array.get(bis, zs1.end_bi_idx)
                    zs1.bx := box.new(begin_bi_for_box.start_time, zs1.zg, end_bi_for_box.end_time, zs1.zd,
                         xloc = xloc.bar_time, bgcolor = ZS_COLOR, border_color = ZS_BORDER_COLOR,
                         border_width = 1)
            else
                zs_idx := zs_idx + 1


    // ========== 清理旧的买卖点 ==========
    if array.size(bsps) > 0
        for i = 0 to array.size(bsps) - 1
            bsp = array.get(bsps, i)
            safe_delete_label(bsp.lbl)
        array.clear(bsps)
    
    // ========== 构建买卖点 ==========
    if bsp_enabled
        int zs_count = array.size(zss)
        
        // 1. 一类买卖点 (T1)
        if is_bsp_type_enabled('1') and zs_count > 0
            for i = 0 to zs_count - 1
                zs = array.get(zss, i)
                
                if not na(zs.bi_out_idx) and not na(zs.bi_in_idx)
                    int zs_bi_count = zs.end_bi_idx - zs.begin_bi_idx + 1
                    bool multi_bi_ok = not bsp1_only_multibi_zs or zs_bi_count >= 3
                    
                    if multi_bi_ok
                        bi_in = array.get(bis, zs.bi_in_idx)
                        bi_out = array.get(bis, zs.bi_out_idx)
                        
                        bool is_break = false
                        bool is_buy = false
                        
                        if bi_out.dir == -1 and bi_out.low < zs.dd
                            is_break := true
                            is_buy := true
                        else if bi_out.dir == 1 and bi_out.high > zs.gg
                            is_break := true
                            is_buy := false
                        
                        if is_break
                            float in_metric = bi_in.macd_metric
                            float out_metric = bi_out.macd_metric
                            float div_rate = out_metric > 0 and in_metric > 0 ? out_metric / in_metric : 1.0
                            
                            if div_rate <= divergence_rate
                                float bsp_price = is_buy ? bi_out.low : bi_out.high
                                new_bsp = BSP.new(is_buy ? 1 : -1, bi_out.idx, i, bsp_price,
                                     bi_out.end_time, bi_out.end_bar, na, div_rate, na)
                                
                                if show_bsp
                                    new_bsp.lbl := label.new(bi_out.end_time, bsp_price,
                                         is_buy ? "1买" : "1卖",
                                         xloc = xloc.bar_time, color = is_buy ? BUY1_COLOR : SELL1_COLOR,
                                         textcolor = color.white,
                                         style = is_buy ? label.style_label_up : label.style_label_down,
                                         size = size.small)
                                
                                array.push(bsps, new_bsp)
        
        // 2. 盘整一类买卖点 (T1P)
        if is_bsp_type_enabled('1p') and array.size(bsps) == 0 and bi_count >= 3
            for i = 2 to bi_count - 1
                last_bi = array.get(bis, i)
                pre_bi = array.get(bis, i - 2)
                
                if last_bi.dir == pre_bi.dir
                    bool no_new_extreme = false
                    if last_bi.dir == -1
                        no_new_extreme := last_bi.low >= pre_bi.low
                    else
                        no_new_extreme := last_bi.high <= pre_bi.high
                    
                    if no_new_extreme
                        float in_metric = pre_bi.macd_metric
                        float out_metric = last_bi.macd_metric
                        float div_rate = out_metric > 0 and in_metric > 0 ? out_metric / in_metric : 1.0
                        
                        if div_rate <= divergence_rate
                            bool is_buy = last_bi.dir == -1
                            float bsp_price = is_buy ? last_bi.low : last_bi.high
                            new_bsp = BSP.new(is_buy ? 11 : -11, i, na, bsp_price,
                                 last_bi.end_time, last_bi.end_bar, na, div_rate, na)
                            
                            if show_bsp
                                new_bsp.lbl := label.new(last_bi.end_time, bsp_price,
                                     is_buy ? "1p买" : "1p卖",
                                     xloc = xloc.bar_time, color = is_buy ? color.orange : color.purple,
                                     textcolor = color.white,
                                     style = is_buy ? label.style_label_up : label.style_label_down,
                                     size = size.small)
                            
                            array.push(bsps, new_bsp)
        
        // 3. 二类买卖点 (T2)
        if is_bsp_type_enabled('2') and bsp2_follow_1 and array.size(bsps) > 0
            int bsp1_count = array.size(bsps)
            for i = 0 to bsp1_count - 1
                bsp1 = array.get(bsps, i)
                
                if math.abs(bsp1.type) == 1 or math.abs(bsp1.type) == 11
                    int bsp2_bi_idx = bsp1.bi_idx + 2
                    
                    if bsp2_bi_idx < bi_count
                        break_bi = array.get(bis, bsp1.bi_idx + 1)
                        bsp2_bi = array.get(bis, bsp2_bi_idx)
                        
                        bool is_buy = bsp1.type > 0
                        bool dir_ok = (is_buy and bsp2_bi.dir == -1) or (not is_buy and bsp2_bi.dir == 1)
                        
                        if dir_ok
                            float retrace_rate = bi_amp(bsp2_bi) / bi_amp(break_bi)
                            
                            if retrace_rate <= max_bs2_rate
                                float bsp_price = is_buy ? bsp2_bi.low : bsp2_bi.high
                                new_bsp = BSP.new(is_buy ? 2 : -2, bsp2_bi_idx, na, bsp_price,
                                     bsp2_bi.end_time, bsp2_bi.end_bar, i, retrace_rate, na)
                                
                                if show_bsp
                                    new_bsp.lbl := label.new(bsp2_bi.end_time, bsp_price,
                                         is_buy ? "2买" : "2卖",
                                         xloc = xloc.bar_time, color = is_buy ? BUY2_COLOR : SELL2_COLOR,
                                         textcolor = color.black,
                                         style = is_buy ? label.style_label_up : label.style_label_down,
                                         size = size.small)
                                
                                array.push(bsps, new_bsp)
        
        // 4. 三类买卖点 (T3A - 中枢之后)
        if is_bsp_type_enabled('3a') and zs_count > 0
            for i = 0 to zs_count - 1
                zs = array.get(zss, i)
                
                if not na(zs.bi_out_idx)
                    int bsp3_bi_idx = zs.bi_out_idx + 1
                    if bsp3_bi_idx < bi_count
                        bi_out = array.get(bis, zs.bi_out_idx)
                        bsp3_bi = array.get(bis, bsp3_bi_idx)
                        
                        bool is_up_break = bi_out.dir == 1 and bi_out.high > zs.zg
                        bool is_down_break = bi_out.dir == -1 and bi_out.low < zs.zd
                        
                        bool not_back = false
                        bool is_buy = false
                        
                        if is_up_break and bsp3_bi.dir == -1
                            not_back := bsp3_bi.low >= zs.zg
                            is_buy := true
                        else if is_down_break and bsp3_bi.dir == 1
                            not_back := bsp3_bi.high <= zs.zd
                            is_buy := false
                        
                        if not_back
                            float bsp_price = is_buy ? bsp3_bi.low : bsp3_bi.high
                            new_bsp = BSP.new(is_buy ? 3 : -3, bsp3_bi_idx, i, bsp_price,
                                 bsp3_bi.end_time, bsp3_bi.end_bar, na, na, na)
                            
                            if show_bsp
                                new_bsp.lbl := label.new(bsp3_bi.end_time, bsp_price,
                                     is_buy ? "3买" : "3卖",
                                     xloc = xloc.bar_time, color = is_buy ? BUY3_COLOR : SELL3_COLOR,
                                     textcolor = color.black,
                                     style = is_buy ? label.style_label_up : label.style_label_down,
                                     size = size.small)
                            
                            array.push(bsps, new_bsp)
        
        // 5. 三类买卖点 (T3B - 中枢之前)
        if is_bsp_type_enabled('3b') and bsp3_follow_1
            int bsp_count = array.size(bsps)
            for i = 0 to bsp_count - 1
                bsp1 = array.get(bsps, i)
                
                if math.abs(bsp1.type) == 1 and not na(bsp1.zs_idx)
                    zs = array.get(zss, bsp1.zs_idx)
                    bool is_buy = bsp1.type == 1
                    
                    int search_start = bsp1.bi_idx + 2
                    bool found = false
                    int bsp3_bi_idx = -1
                    
                    int j = search_start
                    while j < bi_count and not found
                        bi = array.get(bis, j)
                        
                        if is_buy and bi.dir == -1
                            if bi.low >= zs.zg
                                found := true
                                bsp3_bi_idx := j
                        else if not is_buy and bi.dir == 1
                            if bi.high <= zs.zd
                                found := true
                                bsp3_bi_idx := j
                        
                        j := j + 2
                    
                    if found and bsp3_bi_idx >= 0
                        bsp3_bi = array.get(bis, bsp3_bi_idx)
                        float bsp_price = is_buy ? bsp3_bi.low : bsp3_bi.high
                        new_bsp = BSP.new(is_buy ? 3 : -3, bsp3_bi_idx, bsp1.zs_idx, bsp_price,
                             bsp3_bi.end_time, bsp3_bi.end_bar, i, na, na)
                        
                        if show_bsp
                            new_bsp.lbl := label.new(bsp3_bi.end_time, bsp_price,
                                 is_buy ? "3买" : "3卖",
                                 xloc = xloc.bar_time, color = is_buy ? BUY3_COLOR : SELL3_COLOR,
                                 textcolor = color.black,
                                 style = is_buy ? label.style_label_up : label.style_label_down,
                                 size = size.small)
                        
                        array.push(bsps, new_bsp)
    
    // ========== 清理过多的对象，保留最近的 ==========
    // 限制中枢数量，只保留最近的30个
    while array.size(zss) > 30
        old_zs = array.shift(zss)
        safe_delete_box(old_zs.bx)
    
    // 限制买卖点数量，只保留最近的50个
    while array.size(bsps) > 50
        old_bsp = array.shift(bsps)
        safe_delete_label(old_bsp.lbl)


// ============================================================================
// 信息显示
// ============================================================================
plot(close, title = "helper", color = color.new(color.gray, 100), linewidth = 1)

var table info_table = table.new(position.top_right, 2, 12, bgcolor = #ffffff, border_width = 1, border_color = #e0e0e0)

if barstate.islast
    color title_bg = #f5f5f5
    color value_bg = #ffffff
    color title_text = #333333
    color value_text = #1976d2
    
    string level_name = ""
    if timeframe.period == "1"
        level_name := "1分钟"
    else if timeframe.period == "5"
        level_name := "5分钟"
    else if timeframe.period == "15"
        level_name := "15分钟"
    else if timeframe.period == "30"
        level_name := "30分钟"
    else if timeframe.period == "60"
        level_name := "1小时"
    else if timeframe.period == "240"
        level_name := "4小时"
    else if timeframe.period == "D"
        level_name := "日线"
    else if timeframe.period == "W"
        level_name := "周线"
    else if timeframe.period == "M"
        level_name := "月线"
    else
        level_name := timeframe.period
    
    string trend_status = "未知"
    if array.size(zss) > 0 and array.size(bis) > 0
        last_zs = array.last(zss)
        last_bi = array.last(bis)
        
        if last_bi.low > last_zs.zg
            trend_status := "上涨"
        else if last_bi.high < last_zs.zd
            trend_status := "下跌"
        else if last_bi.high >= last_zs.zd and last_bi.low <= last_zs.zg
            trend_status := "盘整"
        else
            trend_status := "震荡"
    
    table.cell(info_table, 0, 0, "当前级别", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 0, level_name, text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 1, "走势状态", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 1, trend_status, text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 2, "合并K线", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 2, str.tostring(array.size(klines)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 3, "分型数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 3, str.tostring(array.size(fractals)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 4, "笔数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 4, str.tostring(array.size(bis)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 5, "线段数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 5, str.tostring(array.size(segs)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 6, "中枢数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 6, str.tostring(array.size(zss)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    table.cell(info_table, 0, 7, "买卖点", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 7, str.tostring(array.size(bsps)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    if array.size(bsps) > 0
        last_bsp = array.last(bsps)
        string bsp_name = ""
        if last_bsp.type == 1
            bsp_name := "1买"
        else if last_bsp.type == -1
            bsp_name := "1卖"
        else if last_bsp.type == 11
            bsp_name := "1p买"
        else if last_bsp.type == -11
            bsp_name := "1p卖"
        else if last_bsp.type == 2
            bsp_name := "2买"
        else if last_bsp.type == -2
            bsp_name := "2卖"
        else if last_bsp.type == 3
            bsp_name := "3买"
        else if last_bsp.type == -3
            bsp_name := "3卖"
        
        table.cell(info_table, 0, 8, "最近信号", text_color = title_text, bgcolor = title_bg, text_size = size.small)
        table.cell(info_table, 1, 8, bsp_name, text_color = last_bsp.type > 0 ? color.green : color.red, bgcolor = value_bg, text_size = size.small)
        
        table.cell(info_table, 0, 9, "信号价格", text_color = title_text, bgcolor = title_bg, text_size = size.small)
        table.cell(info_table, 1, 9, str.tostring(math.round(last_bsp.price, 2)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    
    if array.size(segs) > 0
        last_seg = array.last(segs)
        string seg_dir_str = last_seg.dir == 1 ? "向上" : "向下"
        table.cell(info_table, 0, 10, "当前线段", text_color = title_text, bgcolor = title_bg, text_size = size.small)
        table.cell(info_table, 1, 10, seg_dir_str, text_color = last_seg.dir == 1 ? color.red : color.green, bgcolor = value_bg, text_size = size.small)

// ============================================================================
// 结束
// ============================================================================
