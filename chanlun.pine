//@version=6
indicator('缠论自动画笔中枢 (Chanlun Pro)', '缠论笔中枢', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// === 用户参数 ===
pen_algo = input.string('老笔', title = '画笔算法', options = ['老笔', '新笔/严格笔'])
show_pen_center = input.bool(true, title = '显示笔中枢')
show_fractal_labels = input.bool(false, title = '显示顶底分型标签')
show_divergence_signals = input.bool(true, title = '显示背驰信号')
show_trade_signals = input.bool(true, title = '显示1/2/3买卖点')
divergence_ratio = input.float(0.7, title = 'MACD力度减弱比例(<=该值判背驰)', minval = 0.1, maxval = 1.0, step = 0.05)
min_price_overlap_input = input.float(1.0, title = "中枢最小价格重叠", step = 0.5)
min_price_overlap = min_price_overlap_input * syminfo.mintick

// MACD参数
macd_fast = input.int(12, title = 'MACD快线周期', minval = 1)
macd_slow = input.int(26, title = 'MACD慢线周期', minval = 1)
macd_signal = input.int(9, title = 'MACD信号线周期', minval = 1)

// === 颜色 ===
PEN_COLOR = color.new(color.blue, 0)
PEN_UP_COLOR = color.new(color.red, 0)
PEN_DOWN_COLOR = color.new(color.green, 0)
PEN_CENTER_COLOR = color.new(color.blue, 80)
PEN_WIDTH = 2

// === MACD计算 ===
[macd_line, signal_line, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)

// === 类型定义 ===
type Kx
    float high
    float low
    int time
    int index
    int bar_idx  // 原始bar_index，用于计算MACD面积

type Fx
    float price
    float fx_high
    float fx_low
    int time
    int type      // 1=顶分型, -1=底分型
    label label_id
    int kx_index
    int bar_idx   // 原始bar_index
    bool confirmed // 分型是否已确认

type Pen
    int start_fx_idx
    int end_fx_idx
    float high
    float low
    int direction  // 1=向上笔, -1=向下笔
    int start_time
    int end_time
    int start_bar_idx
    int end_bar_idx
    float macd_area  // MACD面积（力度）
    bool confirmed   // 笔是否已确认

type PenCenter
    float high      // ZG
    float low       // ZD
    int start_time
    int end_time
    int start_pen_idx
    int end_pen_idx
    box box_id
    bool closed     // 中枢是否已封闭
    int direction   // 1=上涨中枢, -1=下跌中枢

type TradeSignal
    int type        // 1=1买, 2=2买, 3=3买, -1=1卖, -2=2卖, -3=3卖
    int bar_idx
    int time
    float price
    int ref_pen_idx
    int ref_center_idx
    label label_id

// === 全局变量 ===
var kx_array = array.new<Kx>()
var pen_fractals = array.new<Fx>()
var pen_lines = array.new<line>()
var pens = array.new<Pen>()
var pen_centers = array.new<PenCenter>()
var trade_signals = array.new<TradeSignal>()
var Kx current_kx = na

// 存储MACD历史值用于面积计算
var macd_hist_array = array.new<float>()

// 买卖点状态追踪
var int last_buy1_pen_idx = na      // 最近1买对应的笔索引
var float last_buy1_price = na      // 1买价格
var int last_sell1_pen_idx = na     // 最近1卖对应的笔索引
var float last_sell1_price = na     // 1卖价格
var int last_closed_center_idx = na // 最近封闭的中枢索引

// === 辅助函数 ===
safe_delete_box(b) =>
    if not na(b)
        box.delete(b)

safe_delete_label(l) =>
    if not na(l)
        label.delete(l)

safe_delete_line(l) =>
    if not na(l)
        line.delete(l)

// 计算指定bar范围内的MACD面积
calc_macd_area(start_bar, end_bar, dir) =>
    float area = 0.0
    int arr_size = array.size(macd_hist_array)
    if arr_size > 0
        for i = math.max(0, start_bar) to math.min(arr_size - 1, end_bar)
            float hist_val = array.get(macd_hist_array, i)
            // 向上笔统计正值面积，向下笔统计负值面积的绝对值
            if dir == 1  // 向上笔
                if hist_val > 0
                    area += hist_val
            else  // 向下笔
                if hist_val < 0
                    area += math.abs(hist_val)
    area

// 添加交易信号标签
add_trade_signal_label(t, price, txt, sig_type) =>
    label lb = na
    if show_trade_signals
        lb := label.new(
             x = t,
             y = price,
             text = txt,
             color = sig_type > 0 ? color.green : color.red,
             textcolor = color.white,
             style = sig_type > 0 ? label.style_label_up : label.style_label_down,
             size = size.small,
             xloc = xloc.bar_time)
    lb

// === 背驰检测 ===
// 检测笔的背驰：比较两段同向笔的MACD面积
detect_bi_divergence(current_pen_idx) =>
    bool has_divergence = false
    float area_current = 0.0
    float area_prev = 0.0
    
    if current_pen_idx >= 2 and current_pen_idx < array.size(pens)
        current_pen = array.get(pens, current_pen_idx)
        
        // 寻找前一个同向笔
        int prev_same_dir_idx = na
        int search_idx = current_pen_idx - 2
        while search_idx >= 0
            prev_pen = array.get(pens, search_idx)
            if prev_pen.direction == current_pen.direction
                prev_same_dir_idx := search_idx
                break
            search_idx := search_idx - 2
        
        if not na(prev_same_dir_idx)
            prev_pen = array.get(pens, prev_same_dir_idx)
            
            // 计算两笔的MACD面积
            area_current := current_pen.macd_area
            area_prev := prev_pen.macd_area
            
            // 判断是否创新高/新低
            bool price_new_extreme = false
            if current_pen.direction == 1  // 向上笔
                price_new_extreme := current_pen.high > prev_pen.high
            else  // 向下笔
                price_new_extreme := current_pen.low < prev_pen.low
            
            // 价格创新极值但力度减弱 = 背驰
            if price_new_extreme and area_prev > 0
                if area_current < area_prev * divergence_ratio
                    has_divergence := true
    
    [has_divergence, area_current, area_prev]

// === 计算多笔的真实重叠区间 ===
get_pens_overlap(pen_indices) =>
    if array.size(pen_indices) < 3
        [na, na]
    else
        first_idx = array.get(pen_indices, 0)
        first_pen = array.get(pens, first_idx)
        float overlap_high = first_pen.high
        float overlap_low = first_pen.low
        
        bool has_valid_overlap = true
        for i = 1 to array.size(pen_indices) - 1
            pen_idx = array.get(pen_indices, i)
            pen = array.get(pens, pen_idx)
            
            float new_low = math.max(overlap_low, pen.low)
            float new_high = math.min(overlap_high, pen.high)
            
            if new_high <= new_low or (new_high - new_low) < min_price_overlap
                has_valid_overlap := false
                break
            
            overlap_high := new_high
            overlap_low := new_low
        
        if has_valid_overlap and overlap_high > overlap_low
            [overlap_high, overlap_low]
        else
            [na, na]

// === 清理所有中枢和信号 ===
cleanup_all_centers_and_signals() =>
    // 清理中枢
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)
    
    // 清理交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    true

// === 第一类买点检测 ===
// 条件：向下笔创新低 + 底背驰 + 底分型确认
// 返回 [triggered, pen_idx, price]
check_buy1(pen_idx, ref_buy1_pen_idx, ref_buy1_price) =>
    bool triggered = false
    int result_pen_idx = ref_buy1_pen_idx
    float result_price = ref_buy1_price
    
    if pen_idx >= 2 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向下笔且已确认
        if pen.direction == -1 and pen.confirmed
            // 检测背驰
            [has_div, area_cur, area_prev] = detect_bi_divergence(pen_idx)
            
            if has_div
                // 寻找前一个向下笔，检查是否创新低
                int prev_down_idx = na
                int search_idx2 = pen_idx - 2
                while search_idx2 >= 0
                    prev = array.get(pens, search_idx2)
                    if prev.direction == -1
                        prev_down_idx := search_idx2
                        break
                    search_idx2 := search_idx2 - 2
                
                if not na(prev_down_idx)
                    prev_pen = array.get(pens, prev_down_idx)
                    if pen.low < prev_pen.low  // 创新低
                        triggered := true
                        result_pen_idx := pen_idx
                        result_price := pen.low
    [triggered, result_pen_idx, result_price]

// === 第一类卖点检测 ===
// 条件：向上笔创新高 + 顶背驰 + 顶分型确认
check_sell1(pen_idx, ref_sell1_pen_idx, ref_sell1_price) =>
    bool triggered = false
    int result_pen_idx = ref_sell1_pen_idx
    float result_price = ref_sell1_price
    
    if pen_idx >= 2 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向上笔且已确认
        if pen.direction == 1 and pen.confirmed
            // 检测背驰
            [has_div, area_cur, area_prev] = detect_bi_divergence(pen_idx)
            
            if has_div
                // 寻找前一个向上笔，检查是否创新高
                int prev_up_idx = na
                int search_idx3 = pen_idx - 2
                while search_idx3 >= 0
                    prev = array.get(pens, search_idx3)
                    if prev.direction == 1
                        prev_up_idx := search_idx3
                        break
                    search_idx3 := search_idx3 - 2
                
                if not na(prev_up_idx)
                    prev_pen = array.get(pens, prev_up_idx)
                    if pen.high > prev_pen.high  // 创新高
                        triggered := true
                        result_pen_idx := pen_idx
                        result_price := pen.high
    [triggered, result_pen_idx, result_price]

// === 第二类买点检测 ===
// 条件：1买后出现向上反弹，然后回调不破1买低点，出现底分型确认
check_buy2(pen_idx, ref_buy1_pen_idx, ref_buy1_price) =>
    bool triggered = false
    if not na(ref_buy1_pen_idx) and pen_idx > ref_buy1_pen_idx + 2 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向下回调笔且已确认
        if pen.direction == -1 and pen.confirmed
            // 回调低点不能破1买低点
            if pen.low >= ref_buy1_price
                // 确保之前有向上反弹
                if pen_idx >= ref_buy1_pen_idx + 2
                    prev_pen = array.get(pens, pen_idx - 1)
                    if prev_pen.direction == 1  // 前一笔是向上
                        triggered := true
    triggered

// === 第二类卖点检测 ===
// 条件：1卖后出现向下回调，然后反弹不破1卖高点，出现顶分型确认
check_sell2(pen_idx, ref_sell1_pen_idx, ref_sell1_price) =>
    bool triggered = false
    if not na(ref_sell1_pen_idx) and pen_idx > ref_sell1_pen_idx + 2 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向上反弹笔且已确认
        if pen.direction == 1 and pen.confirmed
            // 反弹高点不能破1卖高点
            if pen.high <= ref_sell1_price
                // 确保之前有向下回调
                if pen_idx >= ref_sell1_pen_idx + 2
                    prev_pen = array.get(pens, pen_idx - 1)
                    if prev_pen.direction == -1  // 前一笔是向下
                        triggered := true
    triggered

// === 第三类买点检测 ===
// 条件：中枢向上突破后，回调不入中枢（低点 > ZG）
check_buy3(pen_idx) =>
    bool triggered = false
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向下回调笔且已确认
        if pen.direction == -1 and pen.confirmed
            // 检查最近的封闭中枢
            int center_idx = array.size(pen_centers) - 1
            while center_idx >= 0 and not triggered
                center = array.get(pen_centers, center_idx)
                
                if center.closed and pen_idx > center.end_pen_idx + 1
                    // 检查是否有向上突破笔（离开中枢的笔）
                    int exit_pen_idx = center.end_pen_idx + 1
                    if exit_pen_idx < array.size(pens)
                        exit_pen = array.get(pens, exit_pen_idx)
                        
                        // 向上突破：离开笔是向上且高点超过ZG
                        if exit_pen.direction == 1 and exit_pen.high > center.high
                            // 当前回调笔是否在突破后
                            if pen_idx > exit_pen_idx
                                // 回调低点不入中枢（低点 > ZG）
                                if pen.low > center.high
                                    triggered := true
                center_idx := center_idx - 1
    triggered

// === 第三类卖点检测 ===
// 条件：中枢向下跌破后，反弹不入中枢（高点 < ZD）
check_sell3(pen_idx) =>
    bool triggered = false
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向上反弹笔且已确认
        if pen.direction == 1 and pen.confirmed
            // 检查最近的封闭中枢
            int center_idx2 = array.size(pen_centers) - 1
            while center_idx2 >= 0 and not triggered
                center = array.get(pen_centers, center_idx2)
                
                if center.closed and pen_idx > center.end_pen_idx + 1
                    // 检查是否有向下跌破笔（离开中枢的笔）
                    int exit_pen_idx = center.end_pen_idx + 1
                    if exit_pen_idx < array.size(pens)
                        exit_pen = array.get(pens, exit_pen_idx)
                        
                        // 向下跌破：离开笔是向下且低点低于ZD
                        if exit_pen.direction == -1 and exit_pen.low < center.low
                            // 当前反弹笔是否在跌破后
                            if pen_idx > exit_pen_idx
                                // 反弹高点不入中枢（高点 < ZD）
                                if pen.high < center.low
                                    triggered := true
                center_idx2 := center_idx2 - 1
    triggered

// === 中枢检测与构建 ===
check_and_build_centers() =>
    pen_count = array.size(pens)
    
    // 清理所有现有中枢
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)
    
    // 清理旧的交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    
    // 至少需要5笔：进入笔 + 3笔中枢 + 离开笔
    if pen_count >= 5
        int i = 0
        while i <= pen_count - 5
            // 中枢内部笔: i+1, i+2, i+3
            pen_indices = array.new<int>()
            array.push(pen_indices, i + 1)
            array.push(pen_indices, i + 2)
            array.push(pen_indices, i + 3)
            
            [overlap_h, overlap_l] = get_pens_overlap(pen_indices)
            
            if not na(overlap_h) and not na(overlap_l)
                // 检查是否被已有中枢覆盖
                bool is_covered = false
                if array.size(pen_centers) > 0
                    for k = 0 to array.size(pen_centers) - 1
                        existing = array.get(pen_centers, k)
                        if i + 1 >= existing.start_pen_idx and i + 1 <= existing.end_pen_idx
                            is_covered := true
                            break
                
                if not is_covered
                    // 尝试延伸中枢
                    int end_idx = i + 3
                    
                    for j = i + 4 to pen_count - 2
                        extended_indices = array.new<int>()
                        for m = i + 1 to j
                            array.push(extended_indices, m)
                        
                        [ext_h, ext_l] = get_pens_overlap(extended_indices)
                        
                        if not na(ext_h) and not na(ext_l)
                            overlap_h := ext_h
                            overlap_l := ext_l
                            end_idx := j
                        else
                            break
                    
                    // 创建中枢
                    first_pen = array.get(pens, i + 1)
                    last_pen = array.get(pens, end_idx)
                    
                    // 判断中枢方向
                    int center_dir = first_pen.direction == -1 ? -1 : 1
                    
                    // 判断中枢是否封闭（是否有离开笔）
                    bool is_closed = end_idx + 1 < pen_count
                    
                    box new_box = na
                    if show_pen_center
                        new_box := box.new(
                             left = first_pen.start_time, 
                             top = overlap_h, 
                             right = last_pen.end_time, 
                             bottom = overlap_l, 
                             bgcolor = PEN_CENTER_COLOR, 
                             border_color = PEN_COLOR, 
                             border_width = 1, 
                             xloc = xloc.bar_time)
                    
                    array.push(pen_centers, PenCenter.new(
                         overlap_h, 
                         overlap_l, 
                         first_pen.start_time, 
                         last_pen.end_time, 
                         i + 1, 
                         end_idx, 
                         new_box,
                         is_closed,
                         center_dir))
                    
                    // 跳过已处理的笔
                    i := end_idx
            
            i := i + 1
    
    // 处理买卖点信号 - 在主流程中处理
    true

// === 清理函数（笔变化时调用）===
cleanup_after_pen_change() =>
    cleanup_all_centers_and_signals()

// === 主流程 ===
// 存储当前bar的MACD值
array.push(macd_hist_array, macd_hist)

if na(current_kx)
    current_kx := Kx.new(high, low, time, -1, bar_index)
else
    bool has_include = (high >= current_kx.high and low <= current_kx.low) or 
                       (high <= current_kx.high and low >= current_kx.low)
    
    if has_include
        // 包含关系处理
        if array.size(kx_array) >= 1
            prev_kx = array.last(kx_array)
            bool uptrend = high > prev_kx.high or low > prev_kx.low
            
            if uptrend
                current_kx.high := math.max(high, current_kx.high)
                current_kx.low := math.max(low, current_kx.low)
            else
                current_kx.high := math.min(high, current_kx.high)
                current_kx.low := math.min(low, current_kx.low)
        else
            current_kx.high := math.max(high, current_kx.high)
            current_kx.low := math.min(low, current_kx.low)
        
        current_kx.time := time
        current_kx.bar_idx := bar_index
    else
        // 无包含，完成当前K线
        current_kx.index := array.size(kx_array)
        array.push(kx_array, current_kx)
        
        // 分型检测（需要至少3根合并K线）
        if array.size(kx_array) >= 3
            k1 = array.get(kx_array, array.size(kx_array) - 3)
            k2 = array.get(kx_array, array.size(kx_array) - 2)
            k3 = array.get(kx_array, array.size(kx_array) - 1)
            
            is_top = k2.high > k1.high and k2.high > k3.high and 
                     k2.low > k1.low and k2.low > k3.low
            is_bot = k2.low < k1.low and k2.low < k3.low and 
                     k2.high < k1.high and k2.high < k3.high
            
            if is_top or is_bot
                new_price = is_top ? k2.high : k2.low
                new_time = k2.time
                new_type = is_top ? 1 : -1
                new_kx_index = k2.index
                new_bar_idx = k2.bar_idx
                
                // 确认前一个分型（分型确认需等待第4根K线）
                if array.size(pen_fractals) > 0
                    last_fx = array.last(pen_fractals)
                    if not last_fx.confirmed
                        last_fx.confirmed := true
                
                if array.size(pen_fractals) == 0
                    // 第一个分型
                    label lbl = na
                    if show_fractal_labels
                        lbl := label.new(
                             x = new_time, 
                             y = new_price, 
                             text = is_top ? '顶' : '底', 
                             color = PEN_COLOR, 
                             textcolor = color.white, 
                             xloc = xloc.bar_time,
                             size = size.tiny)
                    array.push(pen_fractals, Fx.new(
                         new_price, 
                         k2.high, 
                         k2.low, 
                         new_time, 
                         new_type, 
                         lbl, 
                         new_kx_index,
                         new_bar_idx,
                         false))
                else
                    lastfx = array.last(pen_fractals)
                    
                    if new_type != lastfx.type
                        // 不同类型分型，尝试构建笔
                        bool is_valid = false
                        int kx_gap = new_kx_index - lastfx.kx_index
                        
                        if pen_algo == '新笔/严格笔'
                            if new_type == 1
                                is_valid := kx_gap >= 2 and k2.low > lastfx.fx_high
                            else
                                is_valid := kx_gap >= 2 and k2.high < lastfx.fx_low
                        else
                            is_valid := kx_gap >= 2
                        
                        if is_valid
                            label lbl2 = na
                            if show_fractal_labels
                                lbl2 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time,
                                     size = size.tiny)
                            
                            // 确认上一个分型
                            lastfx.confirmed := true
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl2, 
                                 new_kx_index,
                                 new_bar_idx,
                                 false))
                            
                            // 计算笔的MACD面积
                            float pen_macd_area = calc_macd_area(lastfx.bar_idx, new_bar_idx, new_type)
                            
                            // 确认前一笔（如果存在）
                            if array.size(pens) > 0
                                prev_pen = array.last(pens)
                                prev_pen.confirmed := true
                            
                            // 画笔线
                            line_color = new_type == 1 ? PEN_UP_COLOR : PEN_DOWN_COLOR
                            pline = line.new(
                                 x1 = lastfx.time, 
                                 y1 = lastfx.price, 
                                 x2 = new_time, 
                                 y2 = new_price, 
                                 color = line_color, 
                                 width = PEN_WIDTH, 
                                 xloc = xloc.bar_time)
                            array.push(pen_lines, pline)
                            
                            // 创建笔
                            array.push(pens, Pen.new(
                                 array.size(pen_fractals) - 2, 
                                 array.size(pen_fractals) - 1, 
                                 math.max(lastfx.price, new_price), 
                                 math.min(lastfx.price, new_price), 
                                 new_type,  // direction: 1=向上, -1=向下
                                 lastfx.time, 
                                 new_time,
                                 lastfx.bar_idx,
                                 new_bar_idx,
                                 pen_macd_area,
                                 false))  // 新笔未确认
                            
                            // 重新计算所有中枢和买卖点
                            check_and_build_centers()
                    else
                        // 同类型分型，检查是否需要延伸
                        bool should_replace = false
                        if new_type == 1
                            should_replace := new_price > lastfx.price
                        else
                            should_replace := new_price < lastfx.price
                        
                        if should_replace
                            // 删除旧分型标签
                            if not na(lastfx.label_id)
                                label.delete(lastfx.label_id)
                            
                            // 删除对应的笔线和笔
                            if array.size(pen_lines) > 0
                                line.delete(array.pop(pen_lines))
                            if array.size(pens) > 0
                                array.pop(pens)
                                cleanup_after_pen_change()
                            
                            array.pop(pen_fractals)
                            
                            // 创建新分型
                            label lbl3 = na
                            if show_fractal_labels
                                lbl3 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time,
                                     size = size.tiny)
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl3, 
                                 new_kx_index,
                                 new_bar_idx,
                                 false))
                            
                            // 重新创建笔
                            if array.size(pen_fractals) > 1
                                prevfx = array.get(pen_fractals, array.size(pen_fractals) - 2)
                                float pen_macd_area2 = calc_macd_area(prevfx.bar_idx, new_bar_idx, new_type)
                                
                                line_color = new_type == 1 ? PEN_UP_COLOR : PEN_DOWN_COLOR
                                pline2 = line.new(
                                     x1 = prevfx.time, 
                                     y1 = prevfx.price, 
                                     x2 = new_time, 
                                     y2 = new_price, 
                                     color = line_color, 
                                     width = PEN_WIDTH, 
                                     xloc = xloc.bar_time)
                                array.push(pen_lines, pline2)
                                
                                array.push(pens, Pen.new(
                                     array.size(pen_fractals) - 2, 
                                     array.size(pen_fractals) - 1, 
                                     math.max(prevfx.price, new_price), 
                                     math.min(prevfx.price, new_price), 
                                     new_type, 
                                     prevfx.time, 
                                     new_time,
                                     prevfx.bar_idx,
                                     new_bar_idx,
                                     pen_macd_area2,
                                     false))
                                
                                // 重新计算所有中枢和买卖点
                                check_and_build_centers()
        
        // 开始新的合并K线
        current_kx := Kx.new(high, low, time, -1, bar_index)

// === 处理买卖点信号 ===
if barstate.islast
    pen_count = array.size(pens)
    
    // 清理旧的交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    
    // 重置状态
    last_buy1_pen_idx := na
    last_buy1_price := na
    last_sell1_pen_idx := na
    last_sell1_price := na
    
    // 从头开始扫描所有已确认的笔
    if pen_count >= 3
        for i = 2 to pen_count - 1
            pen = array.get(pens, i)
            
            if pen.confirmed
                // 检查1买
                [buy1_triggered, new_buy1_idx, new_buy1_price] = check_buy1(i, last_buy1_pen_idx, last_buy1_price)
                if buy1_triggered
                    last_buy1_pen_idx := new_buy1_idx
                    last_buy1_price := new_buy1_price
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "1B", 1)
                    array.push(trade_signals, TradeSignal.new(1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
                
                // 检查1卖
                [sell1_triggered, new_sell1_idx, new_sell1_price] = check_sell1(i, last_sell1_pen_idx, last_sell1_price)
                if sell1_triggered
                    last_sell1_pen_idx := new_sell1_idx
                    last_sell1_price := new_sell1_price
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "1S", -1)
                    array.push(trade_signals, TradeSignal.new(-1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
                
                // 检查2买
                if check_buy2(i, last_buy1_pen_idx, last_buy1_price)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "2B", 1)
                    array.push(trade_signals, TradeSignal.new(2, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
                
                // 检查2卖
                if check_sell2(i, last_sell1_pen_idx, last_sell1_price)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "2S", -1)
                    array.push(trade_signals, TradeSignal.new(-2, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
                
                // 检查3买
                if check_buy3(i)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "3B", 1)
                    array.push(trade_signals, TradeSignal.new(3, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
                
                // 检查3卖
                if check_sell3(i)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "3S", -1)
                    array.push(trade_signals, TradeSignal.new(-3, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
    
    // 显示背驰信号
    if show_divergence_signals and pen_count >= 3
        for i = math.max(2, pen_count - 5) to pen_count - 1
            pen = array.get(pens, i)
            if pen.confirmed
                [has_div, area_cur, area_prev] = detect_bi_divergence(i)
                if has_div
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    div_text = pen.direction == 1 ? "顶背驰" : "底背驰"
                    div_color = pen.direction == 1 ? color.red : color.green
                    
                    // 检查是否已有该背驰的1买/1卖标签
                    bool label_exists = false
                    for j = 0 to array.size(trade_signals) - 1
                        sig = array.get(trade_signals, j)
                        if sig.ref_pen_idx == i and (sig.type == 1 or sig.type == -1)
                            label_exists := true
                            break
                    
                    if not label_exists
                        // 显示背驰标签（独立于买卖点）
                        label.new(
                             x = end_fx.time,
                             y = pen.direction == 1 ? pen.high * 1.001 : pen.low * 0.999,
                             text = div_text,
                             color = div_color,
                             textcolor = color.white,
                             style = pen.direction == 1 ? label.style_label_down : label.style_label_up,
                             size = size.tiny,
                             xloc = xloc.bar_time)

// === 辅助图表 ===
plot(close, title = "helper", color = color.new(color.gray, 100), linewidth = 1)

// === 信息表格 ===
var table info_table = table.new(position.top_right, 2, 6, bgcolor = color.new(color.gray, 90))
if barstate.islast
    table.cell(info_table, 0, 0, "合并K线", text_color = color.white)
    table.cell(info_table, 1, 0, str.tostring(array.size(kx_array)), text_color = color.white)
    table.cell(info_table, 0, 1, "分型数", text_color = color.white)
    table.cell(info_table, 1, 1, str.tostring(array.size(pen_fractals)), text_color = color.white)
    table.cell(info_table, 0, 2, "笔数", text_color = color.white)
    table.cell(info_table, 1, 2, str.tostring(array.size(pens)), text_color = color.white)
    table.cell(info_table, 0, 3, "中枢数", text_color = color.white)
    table.cell(info_table, 1, 3, str.tostring(array.size(pen_centers)), text_color = color.white)
    table.cell(info_table, 0, 4, "买卖点", text_color = color.white)
    table.cell(info_table, 1, 4, str.tostring(array.size(trade_signals)), text_color = color.white)
    table.cell(info_table, 0, 5, "算法", text_color = color.white)
    table.cell(info_table, 1, 5, pen_algo, text_color = color.white)
