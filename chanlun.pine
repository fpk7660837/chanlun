//@version=6
indicator('缠论自动画笔中枢 (Chanlun Auto)', '缠论笔中枢', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// === 用户参数 ===
pen_algo = input.string('老笔', title = '画笔算法', options = ['老笔', '新笔/严格笔'])
show_pen_center = input.bool(true, title = '显示笔中枢')
show_fractal_labels = input.bool(false, title = '显示顶底分型标签')
min_price_overlap_input = input.float(1.0, title = "中枢最小价格重叠", step = 0.5)
min_price_overlap = min_price_overlap_input * syminfo.mintick

// === 颜色 ===
PEN_COLOR = color.new(color.blue, 0)
PEN_CENTER_COLOR = color.new(color.blue, 80)
PEN_WIDTH = 2

// === 类型定义 ===
type Kx
    float high
    float low
    int time
    int index
    int bar_index

type Fx
    float price
    float fx_high
    float fx_low
    int time
    int type
    label label_id
    int kx_index

type Pen
    int start_fx_idx
    int end_fx_idx
    float high
    float low
    int direction
    int start_time
    int end_time

type PenCenter
    float high
    float low
    int start_time
    int end_time
    int start_pen_idx
    int end_pen_idx
    box box_id

// === 全局 ===
var kx_array = array.new<Kx>()
var pen_fractals = array.new<Fx>()
var pen_lines = array.new<line>()
var pens = array.new<Pen>()
var pen_centers = array.new<PenCenter>()
var Kx current_kx = na

// === 辅助函数 ===
safe_delete_box(b) =>
    if not na(b)
        box.delete(b)

// === 核心:计算多笔的真实重叠区间 ===
get_pens_overlap(pen_indices) =>
    if array.size(pen_indices) < 3
        [na, na]
    else
        first_idx = array.get(pen_indices, 0)
        first_pen = array.get(pens, first_idx)
        float overlap_high = first_pen.high
        float overlap_low = first_pen.low
        
        bool has_valid_overlap = true
        for i = 1 to array.size(pen_indices) - 1
            pen_idx = array.get(pen_indices, i)
            pen = array.get(pens, pen_idx)
            
            float new_low = math.max(overlap_low, pen.low)
            float new_high = math.min(overlap_high, pen.high)
            
            if new_high <= new_low or (new_high - new_low) < min_price_overlap
                has_valid_overlap := false
                break
            
            overlap_high := new_high
            overlap_low := new_low
        
        if has_valid_overlap and overlap_high > overlap_low
            [overlap_high, overlap_low]
        else
            [na, na]

// === 完全重写中枢检测逻辑 ===
check_and_add_center() =>
    pen_count = array.size(pens)
    
    // 第一步:删除所有现有中枢,重新计算
    // 这样可以确保中枢始终基于当前笔序列的最新状态
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)
    
    // 第二步:只有至少5笔时才检测中枢
    if pen_count >= 5
        // 从最早的笔开始扫描,寻找所有可能的中枢
        // 中枢结构: 笔i(进入) + 笔i+1,i+2,i+3(中枢内部3笔) + 笔i+4(离开)
        
        int i = 0
        while i <= pen_count - 5
            // 尝试从位置i开始构建中枢
            // 中枢内部笔: i+1, i+2, i+3
            pen_indices = array.new<int>()
            array.push(pen_indices, i + 1)
            array.push(pen_indices, i + 2)
            array.push(pen_indices, i + 3)
            
            // 计算这3笔的重叠区间
            [overlap_h, overlap_l] = get_pens_overlap(pen_indices)
            
            // 如果有有效重叠
            if not na(overlap_h) and not na(overlap_l)
                // 检查这个中枢是否已经被之前识别的中枢覆盖
                bool is_covered = false
                if array.size(pen_centers) > 0
                    for k = 0 to array.size(pen_centers) - 1
                        existing = array.get(pen_centers, k)
                        // 如果新中枢的起始笔在已有中枢范围内,跳过
                        if i + 1 >= existing.start_pen_idx and i + 1 <= existing.end_pen_idx
                            is_covered := true
                            break
                
                if not is_covered
                    // 尝试延伸中枢:检查后续笔是否能扩展中枢
                    int end_idx = i + 3
                    
                    // 向后扫描,尝试将更多笔纳入中枢
                    // 但必须保证最后至少留1笔作为离开笔
                    for j = i + 4 to pen_count - 2
                        extended_indices = array.new<int>()
                        for m = i + 1 to j
                            array.push(extended_indices, m)
                        
                        [ext_overlap_h, ext_overlap_l] = get_pens_overlap(extended_indices)
                        
                        if not na(ext_overlap_h) and not na(ext_overlap_l)
                            // 可以延伸
                            overlap_h := ext_overlap_h
                            overlap_l := ext_overlap_l
                            end_idx := j
                        else
                            // 无法延伸,停止
                            break
                    
                    // 创建中枢
                    first_pen = array.get(pens, i + 1)
                    last_pen = array.get(pens, end_idx)
                    
                    box new_box = na
                    if show_pen_center
                        new_box := box.new(
                             left = first_pen.start_time, 
                             top = overlap_h, 
                             right = last_pen.end_time, 
                             bottom = overlap_l, 
                             bgcolor = PEN_CENTER_COLOR, 
                             border_color = PEN_COLOR, 
                             border_width = 1, 
                             xloc = xloc.bar_time)
                    
                    array.push(pen_centers, PenCenter.new(
                         overlap_h, 
                         overlap_l, 
                         first_pen.start_time, 
                         last_pen.end_time, 
                         i + 1, 
                         end_idx, 
                         new_box))
                    
                    // 跳过已经处理的笔
                    i := end_idx
            
            i := i + 1
    
    true

// === 清理函数(简化) ===
cleanup_after_pen_change() =>
    // 当笔被删除或修改时,直接清除所有中枢
    // 下次check_and_add_center()会重新计算
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)

// === 主流程 ===
if na(current_kx)
    current_kx := Kx.new(high, low, time, -1, bar_index)
else
    bool has_include = (high >= current_kx.high and low <= current_kx.low) or 
                       (high <= current_kx.high and low >= current_kx.low)
    
    if has_include
        if array.size(kx_array) >= 1
            prev_kx = array.last(kx_array)
            bool uptrend = high > prev_kx.high or low > prev_kx.low
            
            if uptrend
                current_kx.high := math.max(high, current_kx.high)
                current_kx.low := math.max(low, current_kx.low)
            else
                current_kx.high := math.min(high, current_kx.high)
                current_kx.low := math.min(low, current_kx.low)
        else
            current_kx.high := math.max(high, current_kx.high)
            current_kx.low := math.min(low, current_kx.low)
        
        current_kx.time := time
        current_kx.bar_index := bar_index
    else
        current_kx.index := array.size(kx_array)
        array.push(kx_array, current_kx)
        
        if array.size(kx_array) >= 3
            k1 = array.get(kx_array, array.size(kx_array) - 3)
            k2 = array.get(kx_array, array.size(kx_array) - 2)
            k3 = array.get(kx_array, array.size(kx_array) - 1)
            
            is_top = k2.high > k1.high and k2.high > k3.high and 
                     k2.low > k1.low and k2.low > k3.low
            is_bot = k2.low < k1.low and k2.low < k3.low and 
                     k2.high < k1.high and k2.high < k3.high
            
            if is_top or is_bot
                new_price = is_top ? k2.high : k2.low
                new_time = k2.time
                new_type = is_top ? 1 : -1
                new_kx_index = k2.index
                
                if array.size(pen_fractals) == 0
                    label lbl = na
                    if show_fractal_labels
                        lbl := label.new(
                             x = new_time, 
                             y = new_price, 
                             text = is_top ? '顶' : '底', 
                             color = PEN_COLOR, 
                             textcolor = color.white, 
                             xloc = xloc.bar_time)
                    array.push(pen_fractals, Fx.new(
                         new_price, 
                         k2.high, 
                         k2.low, 
                         new_time, 
                         new_type, 
                         lbl, 
                         new_kx_index))
                else
                    lastfx = array.last(pen_fractals)
                    
                    if new_type != lastfx.type
                        bool is_valid = false
                        int kx_gap = new_kx_index - lastfx.kx_index
                        
                        if pen_algo == '新笔/严格笔'
                            if new_type == 1
                                is_valid := kx_gap >= 2 and k2.low > lastfx.fx_high
                            else
                                is_valid := kx_gap >= 2 and k2.high < lastfx.fx_low
                        else
                            is_valid := kx_gap >= 2
                        
                        if is_valid
                            label lbl2 = na
                            if show_fractal_labels
                                lbl2 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time)
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl2, 
                                 new_kx_index))
                            
                            pline = line.new(
                                 x1 = lastfx.time, 
                                 y1 = lastfx.price, 
                                 x2 = new_time, 
                                 y2 = new_price, 
                                 color = PEN_COLOR, 
                                 width = PEN_WIDTH, 
                                 xloc = xloc.bar_time)
                            array.push(pen_lines, pline)
                            
                            pen_direction = new_type
                            array.push(pens, Pen.new(
                                 array.size(pen_fractals) - 2, 
                                 array.size(pen_fractals) - 1, 
                                 math.max(lastfx.price, new_price), 
                                 math.min(lastfx.price, new_price), 
                                 pen_direction, 
                                 lastfx.time, 
                                 new_time))
                            
                            // 每次添加笔后,重新计算所有中枢
                            bool result = check_and_add_center()
                    else
                        bool should_replace = false
                        if new_type == 1
                            should_replace := new_price > lastfx.price
                        else
                            should_replace := new_price < lastfx.price
                        
                        if should_replace
                            if not na(lastfx.label_id)
                                label.delete(lastfx.label_id)
                            if array.size(pen_lines) > 0
                                line.delete(array.pop(pen_lines))
                            if array.size(pens) > 0
                                array.pop(pens)
                                cleanup_after_pen_change()
                            array.pop(pen_fractals)
                            
                            label lbl3 = na
                            if show_fractal_labels
                                lbl3 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time)
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl3, 
                                 new_kx_index))
                            
                            if array.size(pen_fractals) > 1
                                prevfx = array.get(pen_fractals, array.size(pen_fractals) - 2)
                                pline2 = line.new(
                                     x1 = prevfx.time, 
                                     y1 = prevfx.price, 
                                     x2 = new_time, 
                                     y2 = new_price, 
                                     color = PEN_COLOR, 
                                     width = PEN_WIDTH, 
                                     xloc = xloc.bar_time)
                                array.push(pen_lines, pline2)
                                
                                pen_direction = new_type
                                array.push(pens, Pen.new(
                                     array.size(pen_fractals) - 2, 
                                     array.size(pen_fractals) - 1, 
                                     math.max(prevfx.price, new_price), 
                                     math.min(prevfx.price, new_price), 
                                     pen_direction, 
                                     prevfx.time, 
                                     new_time))
                                
                                // 每次修改笔后,重新计算所有中枢
                                bool result = check_and_add_center()
        
        current_kx := Kx.new(high, low, time, -1, bar_index)

plot(close, title = "helper", color = color.new(color.gray, 90), linewidth = 1)
