//@version=6
indicator('缠论自动画笔中枢 (Chanlun Pro)', '缠论笔中枢', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// === 用户参数 ===
pen_algo = input.string('老笔', title = '画笔算法', options = ['老笔', '新笔/严格笔'])
min_pen_bars = input.int(5, title = '笔最小K线数', minval = 3, maxval = 10, tooltip = '一笔至少需要的合并K线数量')
gap_as_kl = input.bool(true, title = '缺口视为K线', tooltip = '如果两根K线之间有缺口，缺口可视为额外一根K线')
bi_end_is_peak = input.bool(true, title = '笔端点必须是极值', tooltip = '笔的结束点必须是笔内的最高/最低点')

// 中枢设置 (同级别分解: 只使用笔中枢)
zs_algo = input.string('3笔中枢', title = '中枢算法', options = ['3笔中枢', '5笔中枢'], tooltip = '3笔中枢：连续3笔直接构成中枢；5笔中枢：进入笔+3笔中枢+离开笔')
zs_one_bi = input.bool(false, title = '单笔中枢', tooltip = '允许单笔形成中枢')
zs_combine = input.bool(true, title = '中枢合并', tooltip = '相邻中枢有重叠时合并为更大中枢')
min_price_overlap_input = input.float(1.0, title = "中枢最小价格重叠", step = 0.5)
min_price_overlap = min_price_overlap_input * syminfo.mintick

// 买卖点设置
bsp_enabled = input.bool(true, title = '启用买卖点')
bsp_types = input.string('全部', title = '买卖点类型', options = ['全部', '仅1类', '仅2类', '仅3类', '1类+2类', '1类+3类', '2类+3类'], tooltip = '选择要检测的买卖点类型')
bsp_1_only_multi = input.bool(false, title = '1类买卖点仅多笔中枢', tooltip = '只在多笔（>=3笔）中枢中寻找1类买卖点')
bsp_strict_3 = input.bool(false, title = '严格3类买卖点', tooltip = '使用严格的3类买卖点定义')

// 背驰检测
divergence_enabled = input.bool(true, title = '启用背驰检测')
divergence_algo = input.string('area', title = '背驰算法', options = ['area', 'peak', 'slope'], tooltip = '面积法、峰值法或斜率法')
divergence_rate = input.float(0.8, title = '背驰阈值', minval = 0.1, maxval = 1.0, step = 0.05, tooltip = '背驰判断阈值')
use_slope_divergence = input.bool(true, title = '使用笔力度（幅度/天数）判背驰')

// 显示设置
show_pen_center = input.bool(true, title = '显示笔中枢')
show_centers = input.bool(true, title = '显示中枢')
show_fractal_labels = input.bool(false, title = '显示顶底分型标签')
show_divergence_signals = input.bool(true, title = '显示背驰信号')
show_trade_signals = input.bool(true, title = '显示买卖点')
show_labels = input.bool(true, title = '显示价格标签')
show_info_table = input.bool(true, title = '显示信息表')
max_display_items = input.int(500, title = '最大显示数量', maxval = 500)

// MACD参数
macd_fast = input.int(12, title = 'MACD快线周期', minval = 1)
macd_slow = input.int(26, title = 'MACD慢线周期', minval = 1)
macd_signal = input.int(9, title = 'MACD信号线周期', minval = 1)

// === 颜色 ===
PEN_COLOR = color.new(color.blue, 0)
PEN_UP_COLOR = color.new(color.red, 0)
PEN_DOWN_COLOR = color.new(color.green, 0)
PEN_CENTER_COLOR = color.new(color.blue, 80)
PEN_WIDTH = 2

// === MACD计算 ===
[macd_line, signal_line, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)

// === 类型定义 ===
type Kx
    float high
    float low
    int time
    int index
    int bar_idx  // 原始bar_index，用于计算MACD面积

type Fx
    float price
    float fx_high
    float fx_low
    int time
    int type      // 1=顶分型, -1=底分型
    label label_id
    int kx_index
    int bar_idx   // 原始bar_index
    bool confirmed // 分型是否已确认

type Pen
    int start_fx_idx
    int end_fx_idx
    float high
    float low
    int direction  // 1=向上笔, -1=向下笔
    int start_time
    int end_time
    int start_bar_idx
    int end_bar_idx
    float macd_area  // MACD面积（力度）
    bool confirmed   // 笔是否已确认
    int kx_count     // 合并K线数量
    float amplitude  // 笔幅（价格变化）
    float slope      // 笔力度（幅度/天数）

type PenCenter
    float high      // ZG = min(高点1, 高点2)
    float low       // ZD = max(低点1, 低点2)
    float gg        // 中枢最高点
    float dd        // 中枢最低点
    float mid       // 中枢中轴
    int start_time
    int end_time
    int start_pen_idx
    int end_pen_idx
    box box_id
    bool closed     // 中枢是否已封闭
    int direction   // 1=上涨中枢, -1=下跌中枢
    bool extended   // 是否扩展为更大级别中枢
    int level       // 中枢级别
    bool is_breakout // 是否已突破
    float breakout_price // 突破价格

type TradeSignal
    int type        // 1=1买, 2=2买, 3=3买, -1=1卖, -2=2卖, -3=3卖
    int level       // 买卖点级别
    int bar_idx
    int time
    float price
    int ref_pen_idx
    int ref_center_idx
    string reason   // 产生原因
    label label_id

// === 全局变量 ===
var kx_array = array.new<Kx>()
var pen_fractals = array.new<Fx>()
var pen_lines = array.new<line>()
var pens = array.new<Pen>()
var pen_centers = array.new<PenCenter>()
var trade_signals = array.new<TradeSignal>()
var bool current_kx_initialized = false
var Kx current_kx = Kx.new(high, low, time, 0, bar_index)

// 存储MACD历史值用于面积计算
var macd_hist_array = array.new<float>()

// 买卖点状态追踪
var int last_buy1_pen_idx = na      // 最近1买对应的笔索引
var float last_buy1_price = na      // 1买价格
var int last_sell1_pen_idx = na     // 最近1卖对应的笔索引
var float last_sell1_price = na     // 1卖价格
var int last_closed_center_idx = na // 最近封闭的中枢索引

// === 级别检测函数 ===
// 自动检测当前图表周期,返回级别名称
get_current_level() =>
    string level = ""
    if timeframe.period == "1"
        level := "1分钟"
    else if timeframe.period == "3"
        level := "3分钟"
    else if timeframe.period == "5"
        level := "5分钟"
    else if timeframe.period == "15"
        level := "15分钟"
    else if timeframe.period == "30"
        level := "30分钟"
    else if timeframe.period == "60"
        level := "1小时"
    else if timeframe.period == "120"
        level := "2小时"
    else if timeframe.period == "240"
        level := "4小时"
    else if timeframe.period == "D"
        level := "日线"
    else if timeframe.period == "W"
        level := "周线"
    else if timeframe.period == "M"
        level := "月线"
    else
        level := timeframe.period
    level

// 根据当前级别推导次级别
get_sub_level(current_level) =>
    string sub = ""
    if current_level == "月线"
        sub := "周线"
    else if current_level == "周线"
        sub := "日线"
    else if current_level == "日线"
        sub := "4小时"
    else if current_level == "4小时"
        sub := "1小时"
    else if current_level == "2小时"
        sub := "30分钟"
    else if current_level == "1小时"
        sub := "15分钟"
    else if current_level == "30分钟"
        sub := "5分钟"
    else if current_level == "15分钟"
        sub := "3分钟"
    else if current_level == "5分钟"
        sub := "1分钟"
    else if current_level == "3分钟"
        sub := "1分钟"
    else if current_level == "1分钟"
        sub := "笔"
    else
        sub := "次级别"
    sub

// 识别当前走势类型(基于最后一个中枢)
get_current_trend_type() =>
    string trend_type = "未知"

    if array.size(pen_centers) > 0 and array.size(pens) > 0
        last_center = array.get(pen_centers, array.size(pen_centers) - 1)
        last_pen = array.get(pens, array.size(pens) - 1)

        // 如果当前笔在中枢内 → 盘整
        if last_pen.high >= last_center.low and last_pen.low <= last_center.high
            trend_type := "盘整"
        // 如果当前笔在中枢上方 → 可能是上涨
        else if last_pen.low > last_center.high
            trend_type := "上涨"
        // 如果当前笔在中枢下方 → 可能是下跌
        else if last_pen.high < last_center.low
            trend_type := "下跌"
        // 根据中枢方向判断
        else if last_center.direction == 1
            trend_type := "上涨趋势"
        else if last_center.direction == -1
            trend_type := "下跌趋势"
    trend_type

// === 辅助函数 ===
safe_delete_box(b) =>
    if not na(b)
        box.delete(b)

safe_delete_label(l) =>
    if not na(l)
        label.delete(l)

safe_delete_line(l) =>
    if not na(l)
        line.delete(l)

// 判断是否应该检测某类买卖点
should_check_bsp_type(bsp_level) =>
    bool should_check = false
    if bsp_types == '全部'
        should_check := true
    else if bsp_types == '仅1类' and bsp_level == 1
        should_check := true
    else if bsp_types == '仅2类' and bsp_level == 2
        should_check := true
    else if bsp_types == '仅3类' and bsp_level == 3
        should_check := true
    else if bsp_types == '1类+2类' and (bsp_level == 1 or bsp_level == 2)
        should_check := true
    else if bsp_types == '1类+3类' and (bsp_level == 1 or bsp_level == 3)
        should_check := true
    else if bsp_types == '2类+3类' and (bsp_level == 2 or bsp_level == 3)
        should_check := true
    should_check

// 添加交易信号标签
add_trade_signal_label(t, price, txt, sig_type, tooltip = "") =>
    label lb = na
    if show_trade_signals
        lb := label.new(
             x = t,
             y = price,
             text = txt,
             color = sig_type > 0 ? color.green : color.red,
             textcolor = color.white,
             style = sig_type > 0 ? label.style_label_up : label.style_label_down,
             size = size.small,
             xloc = xloc.bar_time,
             tooltip = tooltip)
    lb

// === 绘图对象管理 ===
// 清理旧的绘图对象以保持在限制范围内
cleanup_drawing_objects() =>
    // 清理多余的笔线
    while array.size(pen_lines) > max_display_items
        line.delete(array.shift(pen_lines))

    // 清理过多的中枢框
    while array.size(pen_centers) > max_display_items / 3
        center = array.shift(pen_centers)
        safe_delete_box(center.box_id)

    // 清理过多的买卖点标签
    int max_signals = max_display_items
    while array.size(trade_signals) > max_signals
        sig = array.shift(trade_signals)
        safe_delete_label(sig.label_id)

// 按优先级显示
draw_by_priority() =>
    if barstate.islast
        // 1. 确保显示最新的买卖点（最高优先级）
        if array.size(trade_signals) > 0
            latest_signals = array.slice(trade_signals, math.max(0, array.size(trade_signals) - 5), array.size(trade_signals))
            for i = 0 to array.size(latest_signals) - 1
                sig = array.get(latest_signals, i)
                if na(sig.label_id) and show_trade_signals
                    // 根据信号类型生成适当的tooltip
                    string tooltip = ""
                    if sig.type == 1
                        tooltip := "【1买】\n\n类型: 第一类买点"
                    else if sig.type == -1
                        tooltip := "【1卖】\n\n类型: 第一类卖点"
                    else if sig.type == 2
                        tooltip := "【2买】\n\n类型: 第二类买点"
                    else if sig.type == -2
                        tooltip := "【2卖】\n\n类型: 第二类卖点"
                    else if sig.type == 3
                        tooltip := "【3买】\n\n类型: 第三类买点"
                    else if sig.type == -3
                        tooltip := "【3卖】\n\n类型: 第三类卖点"

                    sig.label_id := add_trade_signal_label(sig.time, sig.price,
                        sig.type == 1 ? "1买" : sig.type == -1 ? "1卖" :
                        sig.type == 2 ? "2买" : sig.type == -2 ? "2卖" :
                        sig.type == 3 ? "3买" : sig.type == -3 ? "3卖" : "",
                        sig.type > 0 ? 1 : -1, tooltip)

        // 2. 确保显示当前中枢
        if array.size(pen_centers) > 0 and show_pen_center
            latest_center = array.get(pen_centers, array.size(pen_centers) - 1)
            if na(latest_center.box_id)
                latest_center.box_id := box.new(
                    left = latest_center.start_time,
                    top = latest_center.high,
                    right = latest_center.end_time,
                    bottom = latest_center.low,
                    bgcolor = PEN_CENTER_COLOR,
                    border_color = PEN_COLOR,
                    border_width = 1,
                    xloc = xloc.bar_time)

        // 3. 确保显示最近的笔
        if array.size(pen_lines) > 0 and show_pen_center
            int recent_count = math.min(max_display_items, array.size(pen_lines))
            recent_lines = array.slice(pen_lines, array.size(pen_lines) - recent_count, array.size(pen_lines))
            // 确保最近的笔线存在（已在创建时处理）

        // 4. 清理多余对象（临时注释以调试显示问题）
        // cleanup_drawing_objects()

// 检查两根合并K线之间是否有缺口
has_gap_between(kx1_idx, kx2_idx) =>
    bool has_gap = false
    if kx1_idx >= 0 and kx2_idx > kx1_idx and kx2_idx < array.size(kx_array)
        kx1 = array.get(kx_array, kx1_idx)
        kx2 = array.get(kx_array, kx2_idx)
        // 缺口：两根K线高低无重叠
        has_gap := kx1.high < kx2.low or kx1.low > kx2.high
    has_gap

// 计算两个分型之间的缺口数量（用于gap_as_kl）
count_gaps_between(start_kx_idx, end_kx_idx) =>
    int gap_count = 0
    if gap_as_kl and start_kx_idx >= 0 and end_kx_idx > start_kx_idx
        for i = start_kx_idx to end_kx_idx - 1
            if has_gap_between(i, i + 1)
                gap_count := gap_count + 1
    gap_count

// 检查笔端点是否是极值（参考Python的end_is_peak）
check_end_is_peak(start_kx_idx, end_kx_idx, is_up) =>
    bool is_peak = true
    if bi_end_is_peak and start_kx_idx >= 0 and end_kx_idx > start_kx_idx
        end_kx = array.get(kx_array, end_kx_idx)
        float cmp_value = is_up ? end_kx.high : end_kx.low
        // 检查笔内所有K线，确保端点是极值
        for i = start_kx_idx + 1 to end_kx_idx - 1
            kx = array.get(kx_array, i)
            if is_up and kx.high > cmp_value
                is_peak := false
                break
            if not is_up and kx.low < cmp_value
                is_peak := false
                break
    is_peak

// 计算指定bar范围内的MACD面积
calc_macd_area(start_bar, end_bar, dir) =>
    float area = 0.0
    int arr_size = array.size(macd_hist_array)
    if arr_size > 0
        for i = math.max(0, start_bar) to math.min(arr_size - 1, end_bar)
            float hist_val = array.get(macd_hist_array, i)
            // 向上笔统计正值面积，向下笔统计负值面积的绝对值
            if dir == 1  // 向上笔
                if hist_val > 0
                    area += hist_val
            else  // 向下笔
                if hist_val < 0
                    area += math.abs(hist_val)
    area

// === 背驰检测 ===
// 检测笔的背驰：比较两段同向笔的MACD面积和笔力度
detect_bi_divergence(current_pen_idx) =>
    bool has_divergence = false
    float area_current = 0.0
    float area_prev = 0.0
    bool macd_div = false
    bool slope_div = false

    if current_pen_idx >= 2 and current_pen_idx < array.size(pens)
        current_pen = array.get(pens, current_pen_idx)

        // 寻找前一个同向笔
        int prev_same_dir_idx = na
        int search_idx = current_pen_idx - 2
        while search_idx >= 0
            prev_pen = array.get(pens, search_idx)
            if prev_pen.direction == current_pen.direction
                prev_same_dir_idx := search_idx
                break
            search_idx := search_idx - 2

        if not na(prev_same_dir_idx)
            prev_pen = array.get(pens, prev_same_dir_idx)

            // 计算两笔的MACD面积
            area_current := current_pen.macd_area
            area_prev := prev_pen.macd_area

            // 判断是否创新高/新低
            bool price_new_extreme = false
            if current_pen.direction == 1  // 向上笔
                price_new_extreme := current_pen.high > prev_pen.high
            else  // 向下笔
                price_new_extreme := current_pen.low < prev_pen.low

            // MACD背驰：价格创新极值但MACD力度减弱
            if price_new_extreme and area_prev > 0
                if area_current < area_prev * divergence_rate
                    macd_div := true

            // 笔力度背驰（参考Rust实现）：笔天数>=前笔 且 (笔幅<前笔 或 笔力度<前笔)
            if use_slope_divergence and price_new_extreme
                bool bars_longer = current_pen.kx_count >= prev_pen.kx_count
                bool amp_weaker = current_pen.amplitude < prev_pen.amplitude
                bool slope_weaker = current_pen.slope < prev_pen.slope * divergence_rate
                if bars_longer and (amp_weaker or slope_weaker)
                    slope_div := true

            // MACD背驰或笔力度背驰任一成立
            has_divergence := macd_div or slope_div

    [has_divergence, area_current, area_prev]

// === 计算多笔的真实重叠区间 ===
get_pens_overlap(pen_indices) =>
    if array.size(pen_indices) < 3
        [na, na]
    else
        first_idx = array.get(pen_indices, 0)
        first_pen = array.get(pens, first_idx)
        float overlap_high = first_pen.high
        float overlap_low = first_pen.low

        bool has_valid_overlap = true
        for i = 1 to array.size(pen_indices) - 1
            pen_idx = array.get(pen_indices, i)
            pen = array.get(pens, pen_idx)

            float new_low = math.max(overlap_low, pen.low)
            float new_high = math.min(overlap_high, pen.high)

            if new_high <= new_low or (new_high - new_low) < min_price_overlap
                has_valid_overlap := false
                break

            overlap_high := new_high
            overlap_low := new_low

        if has_valid_overlap and overlap_high > overlap_low
            [overlap_high, overlap_low]
        else
            [na, na]

// === 清理所有中枢和信号 ===
cleanup_all_centers_and_signals() =>
    // 清理中枢
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)

    // 清理交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    true

// === 第一类买点检测 ===
// 缠论原文定义：某级别下跌趋势中，一个次级别走势类型向下跌破最后一个缠中说禅走势中枢后形成的背驰点
// 关键：
// 1. 必须在下跌趋势中(中枢前后都有向下笔)
// 2. 向下离开中枢，跌破ZD(中枢下沿)
// 3. 与前一个离开中枢的向下笔相比形成背驰
// 返回 [triggered, pen_idx, price, type]
check_buy1(pen_idx, ref_buy1_pen_idx, ref_buy1_price) =>
    bool triggered = false
    int result_pen_idx = ref_buy1_pen_idx
    float result_price = ref_buy1_price
    int signal_type = 1  // 1买

    // 需要至少有一个中枢
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 必须是已确认的向下笔
        if pen.direction == -1 and pen.confirmed
            // 找到当前笔相关的中枢：
            // 1. 中枢必须在当前笔之前结束
            // 2. 当前笔应该是离开中枢的笔(即中枢结束后的下跌笔)
            int relevant_center_idx = na
            for i = array.size(pen_centers) - 1 to 0
                center = array.get(pen_centers, i)
                // 中枢必须在当前笔开始之前
                if center.end_pen_idx < pen_idx and center.closed
                    // 检查当前笔是否跌破了这个中枢的ZD
                    if pen.low < center.low
                        relevant_center_idx := i
                        break

            if not na(relevant_center_idx)
                relevant_center = array.get(pen_centers, relevant_center_idx)

                // 如果启用了"仅多笔中枢"，检查中枢笔数
                bool center_valid = true
                if bsp_1_only_multi
                    int center_pen_count = relevant_center.end_pen_idx - relevant_center.start_pen_idx + 1
                    center_valid := center_pen_count >= 3

                if center_valid
                    // 找到进入这个中枢前的向下笔(作为背驰比较的对象)
                    // 这应该是中枢开始之前的那个向下笔
                    int prev_down_idx = na

                    // 方法1：找中枢进入笔的前一笔
                    int enter_pen_idx = relevant_center.start_pen_idx
                    if enter_pen_idx > 0
                        potential_prev = array.get(pens, enter_pen_idx - 1)
                        if potential_prev.direction == -1
                            prev_down_idx := enter_pen_idx - 1

                    // 方法2：如果方法1失败，向前搜索最近的向下笔
                    if na(prev_down_idx)
                        for j = relevant_center.start_pen_idx - 1 to 0
                            search_pen = array.get(pens, j)
                            if search_pen.direction == -1
                                prev_down_idx := j
                                break

                    if not na(prev_down_idx)
                        prev_pen = array.get(pens, prev_down_idx)

                        // 价格必须创新低
                        bool price_new_low = pen.low < prev_pen.low

                        if price_new_low
                            // MACD背驰检测
                            bool macd_div = false
                            if divergence_enabled and pen.macd_area > 0 and prev_pen.macd_area > 0
                                macd_div := pen.macd_area < prev_pen.macd_area * divergence_rate

                            // 笔力度背驰
                            bool slope_div = false
                            if use_slope_divergence
                                slope_div := pen.slope < prev_pen.slope * divergence_rate

                            // 背驰条件：创新低且(MACD背驰 OR 力度背驰)
                            // 满足任一背驰即可触发
                            if macd_div or slope_div
                                triggered := true
                                result_pen_idx := pen_idx
                                result_price := pen.low
    [triggered, result_pen_idx, result_price, signal_type]

// === 第一类卖点检测 ===
// 缠论原文定义：某级别上涨趋势中，一个次级别走势类型向上突破最后一个缠中说禅走势中枢后形成的背驰点
// 关键：
// 1. 必须在上涨趋势中(中枢前后都有向上笔)
// 2. 向上离开中枢，突破ZG(中枢上沿)
// 3. 与前一个离开中枢的向上笔相比形成背驰
check_sell1(pen_idx, ref_sell1_pen_idx, ref_sell1_price) =>
    bool triggered = false
    int result_pen_idx = ref_sell1_pen_idx
    float result_price = ref_sell1_price
    int signal_type = -1  // 1卖

    // 需要至少有一个中枢
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 必须是已确认的向上笔
        if pen.direction == 1 and pen.confirmed
            // 找到当前笔相关的中枢：
            // 1. 中枢必须在当前笔之前结束
            // 2. 当前笔应该是离开中枢的笔(即中枢结束后的上涨笔)
            int relevant_center_idx = na
            for i = array.size(pen_centers) - 1 to 0
                center = array.get(pen_centers, i)
                // 中枢必须在当前笔开始之前
                if center.end_pen_idx < pen_idx and center.closed
                    // 检查当前笔是否突破了这个中枢的ZG
                    if pen.high > center.high
                        relevant_center_idx := i
                        break

            if not na(relevant_center_idx)
                relevant_center = array.get(pen_centers, relevant_center_idx)

                // 如果启用了"仅多笔中枢"，检查中枢笔数
                bool center_valid = true
                if bsp_1_only_multi
                    int center_pen_count = relevant_center.end_pen_idx - relevant_center.start_pen_idx + 1
                    center_valid := center_pen_count >= 3

                if center_valid
                    // 找到进入这个中枢前的向上笔(作为背驰比较的对象)
                    // 这应该是中枢开始之前的那个向上笔
                    int prev_up_idx = na

                    // 方法1：找中枢进入笔的前一笔
                    int enter_pen_idx = relevant_center.start_pen_idx
                    if enter_pen_idx > 0
                        potential_prev = array.get(pens, enter_pen_idx - 1)
                        if potential_prev.direction == 1
                            prev_up_idx := enter_pen_idx - 1

                    // 方法2：如果方法1失败，向前搜索最近的向上笔
                    if na(prev_up_idx)
                        for j = relevant_center.start_pen_idx - 1 to 0
                            search_pen = array.get(pens, j)
                            if search_pen.direction == 1
                                prev_up_idx := j
                                break

                    if not na(prev_up_idx)
                        prev_pen = array.get(pens, prev_up_idx)

                        // 价格必须创新高
                        bool price_new_high = pen.high > prev_pen.high

                        if price_new_high
                            // MACD背驰检测
                            bool macd_div = false
                            if divergence_enabled and pen.macd_area > 0 and prev_pen.macd_area > 0
                                macd_div := pen.macd_area < prev_pen.macd_area * divergence_rate

                            // 笔力度背驰
                            bool slope_div = false
                            if use_slope_divergence
                                slope_div := pen.slope < prev_pen.slope * divergence_rate

                            // 背驰条件：创新高且(MACD背驰 OR 力度背驰)
                            // 满足任一背驰即可触发
                            if macd_div or slope_div
                                triggered := true
                                result_pen_idx := pen_idx
                                result_price := pen.high
    [triggered, result_pen_idx, result_price, signal_type]

// === 第二类买点检测 ===
// 缠论原文定义：某级别中，第一类买点的次级别上涨结束后再次下跌的那个次级别走势类型的结束点
// 关键：
// 1. 必须存在已确认的第一类买点
// 2. 结构：1买 → 上涨笔 → 下跌笔(当前)
// 3. 当前笔是1买之后第二笔(pen_idx = buy1_idx + 2)
// 4. 回调低点不应显著低于1买位置(允许小幅突破)
check_buy2(pen_idx, ref_buy1_pen_idx, ref_buy1_price) =>
    bool triggered = false
    int signal_type = 2  // 2买

    // 需要B1存在，且当前笔正好是B1后的第二笔
    if not na(ref_buy1_pen_idx) and pen_idx == ref_buy1_pen_idx + 2 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 必须是向下笔且已确认
        if pen.direction == -1 and pen.confirmed
            // 检查中间笔(B1之后的第一笔)是否为上涨笔
            if ref_buy1_pen_idx + 1 < array.size(pens)
                middle_pen = array.get(pens, ref_buy1_pen_idx + 1)

                // 确认结构：1买 → 上涨笔 → 下跌笔
                if middle_pen.direction == 1
                    // 允许小幅突破1买位置(2%容差)
                    float tolerance = ref_buy1_price * 0.02
                    if pen.low >= ref_buy1_price - tolerance
                        triggered := true

    [triggered, signal_type]

// === 第二类卖点检测 ===
// 缠论原文定义：某级别中，第一类卖点的次级别下跌结束后再次上涨的那个次级别走势类型的结束点
// 关键：
// 1. 必须存在已确认的第一类卖点
// 2. 结构：1卖 → 下跌笔 → 上涨笔(当前)
// 3. 当前笔是1卖之后第二笔(pen_idx = sell1_idx + 2)
// 4. 反弹高点不应显著高于1卖位置(允许小幅突破)
check_sell2(pen_idx, ref_sell1_pen_idx, ref_sell1_price) =>
    bool triggered = false
    int signal_type = -2  // 2卖

    // 需要S1存在，且当前笔正好是S1后的第二笔
    if not na(ref_sell1_pen_idx) and pen_idx == ref_sell1_pen_idx + 2 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 必须是向上笔且已确认
        if pen.direction == 1 and pen.confirmed
            // 检查中间笔(S1之后的第一笔)是否为下跌笔
            if ref_sell1_pen_idx + 1 < array.size(pens)
                middle_pen = array.get(pens, ref_sell1_pen_idx + 1)

                // 确认结构：1卖 → 下跌笔 → 上涨笔
                if middle_pen.direction == -1
                    // 允许小幅突破1卖位置(2%容差)
                    float tolerance = ref_sell1_price * 0.02
                    if pen.high <= ref_sell1_price + tolerance
                        triggered := true

    [triggered, signal_type]

// === 第三类买点检测 ===
// 缠论原文定义：
// 一个次级别走势类型向上离开缠中说禅走势中枢，然后以一个次级别走势类型回试，
// 其低点不跌破ZG，则构成第三类买点
// 关键：
// 1. 存在上涨中枢(下-上-下结构, direction = 1)
// 2. 中枢完成后，向上突破ZG，形成离开笔
// 3. 随后回调形成下跌笔
// 4. 回调低点 >= ZG (不跌破中枢上沿，即不重新进入中枢)
// 5. 回调笔结束点 → 第三类买点
check_buy3(pen_idx) =>
    bool triggered = false
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 必须是向下回调笔且已确认
        if pen.direction == -1 and pen.confirmed
            // 检查当前笔是否是离开笔之后的回调笔
            // 结构应该是：中枢 → 离开笔(向上) → 回调笔(当前，向下)
            if pen_idx >= 1
                prev_pen = array.get(pens, pen_idx - 1)

                // 前一笔应该是向上笔(离开笔)
                if prev_pen.direction == 1
                    // 检查所有可能的中枢
                    int center_idx = array.size(pen_centers) - 1
                    while center_idx >= 0 and not triggered
                        center = array.get(pen_centers, center_idx)

                        // 条件1：必须是上涨中枢(下-上-下结构)
                        // 条件2：中枢已封闭
                        // 条件3：离开笔(prev_pen)应该紧接在中枢之后
                        if center.direction == 1 and center.closed
                            int expected_exit_pen_idx = center.end_pen_idx + 1

                            // 离开笔是中枢结束后的第一笔
                            if pen_idx - 1 == expected_exit_pen_idx
                                // 条件4：离开笔向上突破ZG
                                if prev_pen.high > center.high
                                    // 条件5：回调笔低点 >= ZG (不重新进入中枢)
                                    if pen.low >= center.high
                                        triggered := true
                        center_idx := center_idx - 1
    triggered

// === 第三类卖点检测 ===
// 缠论原文定义：
// 一个次级别走势类型向下离开缠中说禅走势中枢，然后以一个次级别走势类型回试，
// 其高点不升破ZD，则构成第三类卖点
// 关键：
// 1. 存在下跌中枢(上-下-上结构, direction = -1)
// 2. 中枢完成后，向下跌破ZD，形成离开笔
// 3. 随后反弹形成上涨笔
// 4. 反弹高点 <= ZD (不升破中枢下沿，即不重新进入中枢)
// 5. 反弹笔结束点 → 第三类卖点
check_sell3(pen_idx) =>
    bool triggered = false
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 必须是向上反弹笔且已确认
        if pen.direction == 1 and pen.confirmed
            // 检查当前笔是否是离开笔之后的反弹笔
            // 结构应该是：中枢 → 离开笔(向下) → 反弹笔(当前，向上)
            if pen_idx >= 1
                prev_pen = array.get(pens, pen_idx - 1)

                // 前一笔应该是向下笔(离开笔)
                if prev_pen.direction == -1
                    // 检查所有可能的中枢
                    int center_idx2 = array.size(pen_centers) - 1
                    while center_idx2 >= 0 and not triggered
                        center = array.get(pen_centers, center_idx2)

                        // 条件1：必须是下跌中枢(上-下-上结构)
                        // 条件2：中枢已封闭
                        // 条件3：离开笔(prev_pen)应该紧接在中枢之后
                        if center.direction == -1 and center.closed
                            int expected_exit_pen_idx = center.end_pen_idx + 1

                            // 离开笔是中枢结束后的第一笔
                            if pen_idx - 1 == expected_exit_pen_idx
                                // 条件4：离开笔向下跌破ZD
                                if prev_pen.low < center.low
                                    // 条件5：反弹笔高点 <= ZD (不重新进入中枢)
                                    if pen.high <= center.low
                                        triggered := true
                        center_idx2 := center_idx2 - 1
    triggered

// === 基于笔的中枢构建 ===
build_pen_centers() =>
    pen_count = array.size(pens)

    // 根据算法选择不同的中枢构建逻辑
    if zs_algo == '3笔中枢'
        // ============ 3笔中枢算法（同级别分解）============
        // 连续3笔直接构成中枢
        // 同级别分解关键：相邻中枢可以共享边界笔
        // 例如：中枢1[笔0,1,2] → 中枢2[笔2,3,4] （笔2既是中枢1的离开笔，也是中枢2的进入笔）
        if pen_count >= 3
            int i = 0
            while i <= pen_count - 3
                pen1 = array.get(pens, i)
                pen2 = array.get(pens, i + 1)
                pen3 = array.get(pens, i + 2)

                // 验证中枢结构：下-上-下(上涨中枢) 或 上-下-上(下跌中枢)
                bool valid_structure = false
                int center_dir = 0

                // 上涨中枢：笔1向下 → 笔2向上 → 笔3向下
                if pen1.direction == -1 and pen2.direction == 1 and pen3.direction == -1
                    valid_structure := true
                    center_dir := 1  // 上涨中枢
                // 下跌中枢：笔1向上 → 笔2向下 → 笔3向上
                else if pen1.direction == 1 and pen2.direction == -1 and pen3.direction == 1
                    valid_structure := true
                    center_dir := -1  // 下跌中枢

                if valid_structure
                    // 根据缠论正确定义计算中枢
                    // ZG = min(g1, g2) - 前两个高点的较小者
                    // ZD = max(d1, d2) - 前两个低点的较大者
                    float zg = 0.0
                    float zd = 0.0

                    if center_dir == 1  // 上涨中枢：下-上-下
                        // g1 = pen2.high, g2 = pen3.high
                        // d1 = pen1.low, d2 = pen2.low
                        zg := math.min(pen2.high, pen3.high)
                        zd := math.max(pen1.low, pen2.low)
                    else  // 下跌中枢：上-下-上
                        // g1 = pen1.high, g2 = pen2.high
                        // d1 = pen2.low, d2 = pen3.low
                        zg := math.min(pen1.high, pen2.high)
                        zd := math.max(pen2.low, pen3.low)

                    // GG = 中枢组件中的最高点
                    float center_gg = math.max(pen1.high, math.max(pen2.high, pen3.high))
                    // DD = 中枢组件中的最低点
                    float center_dd = math.min(pen1.low, math.min(pen2.low, pen3.low))

                    if zg >= zd + min_price_overlap
                        // 检查当前笔是否已被之前的中枢完全覆盖
                        // 同级别分解：只检查起始笔是否被覆盖，允许共享边界笔
                        bool is_covered = false
                        if array.size(pen_centers) > 0
                            for k = 0 to array.size(pen_centers) - 1
                                existing = array.get(pen_centers, k)
                                // 只有当起始笔被前一个中枢内部包含时才算被覆盖
                                // 允许 i == existing.end_pen_idx（共享边界笔）
                                if i > existing.start_pen_idx and i < existing.end_pen_idx
                                    is_covered := true
                                    break

                        if not is_covered
                            int end_idx = i + 2

                            // 尝试延伸中枢（只有当有更多笔时才尝试）
                            if i + 3 < pen_count
                                for j = i + 3 to pen_count - 1
                                    ext_pen = array.get(pens, j)
                                    bool enters_zs = ext_pen.high >= zd and ext_pen.low <= zg
                                    if enters_zs
                                        float new_zg = math.min(zg, ext_pen.high)
                                        float new_zd = math.max(zd, ext_pen.low)
                                        if new_zg >= new_zd + min_price_overlap
                                            zg := new_zg
                                            zd := new_zd
                                            end_idx := j
                                            center_gg := math.max(center_gg, ext_pen.high)
                                            center_dd := math.min(center_dd, ext_pen.low)
                                        else
                                            break
                                    else
                                        break

                            float center_mid = (zg + zd) / 2
                            bool is_closed = end_idx + 1 < pen_count
                            last_pen = array.get(pens, end_idx)

                            box new_box = na
                            if show_pen_center
                                new_box := box.new(left = pen1.start_time, top = zg, right = last_pen.end_time, bottom = zd,
                                     bgcolor = PEN_CENTER_COLOR, border_color = PEN_COLOR, border_width = 1, xloc = xloc.bar_time)

                            array.push(pen_centers, PenCenter.new(zg, zd, center_gg, center_dd, center_mid, pen1.start_time, last_pen.end_time,
                                 i, end_idx, new_box, is_closed, center_dir, false, 1, false, 0.0))

                            // 同级别分解关键修改：
                            // 允许下一个中枢从当前中枢的最后一笔开始（共享边界笔）
                            // 如果中枢只有3笔，下一个中枢可以从第2笔开始
                            // 如果中枢被延伸，下一个中枢可以从倒数第2笔开始
                            if end_idx > i + 2
                                // 中枢被延伸了，从倒数第2笔开始寻找下一个中枢
                                i := end_idx - 1
                            else
                                // 标准3笔中枢，从第2笔开始寻找下一个中枢
                                i := i + 1
                        else
                            i := i + 1
                    else
                        i := i + 1
                else
                    i := i + 1
    else
        // ============ 5笔中枢算法（同级别分解）============
        // 需要至少4笔：进入笔 + 3笔中枢（中枢可以不需要离开笔）
        // 同级别分解关键：相邻中枢可以共享边界笔
        // 例如：进入笔0 + 中枢1[笔1,2,3] → 进入笔2 + 中枢2[笔3,4,5]（笔3既是中枢1的一部分，也是中枢2的一部分）
        if pen_count >= 4
            int i = 0
            while i <= pen_count - 4
                // 中枢内部笔: i+1, i+2, i+3
                pen_in = array.get(pens, i)      // 进入笔
                pen1 = array.get(pens, i + 1)
                pen2 = array.get(pens, i + 2)
                pen3 = array.get(pens, i + 3)

                // 验证结构：进入笔+中枢必须方向相反
                bool valid_structure = false
                int center_dir = 0

                // 进入笔向下 → 上涨中枢（中枢内部是下-上-下）
                if pen_in.direction == -1 and pen1.direction == -1 and pen2.direction == 1 and pen3.direction == -1
                    valid_structure := true
                    center_dir := 1
                // 进入笔向上 → 下跌中枢（中枢内部是上-下-上）
                else if pen_in.direction == 1 and pen1.direction == 1 and pen2.direction == -1 and pen3.direction == 1
                    valid_structure := true
                    center_dir := -1

                if valid_structure
                    // 根据缠论正确定义计算中枢
                    // 中枢由pen1, pen2, pen3三笔构成
                    // ZG = min(g1, g2) - 前两个高点的较小者
                    // ZD = max(d1, d2) - 前两个低点的较大者
                    float zg = 0.0
                    float zd = 0.0

                    if center_dir == 1  // 上涨中枢：中枢为下-上-下
                        // g1 = pen2.high, g2 = pen3.high
                        // d1 = pen1.low, d2 = pen2.low
                        zg := math.min(pen2.high, pen3.high)
                        zd := math.max(pen1.low, pen2.low)
                    else  // 下跌中枢：中枢为上-下-上
                        // g1 = pen1.high, g2 = pen2.high
                        // d1 = pen2.low, d2 = pen3.low
                        zg := math.min(pen1.high, pen2.high)
                        zd := math.max(pen2.low, pen3.low)

                    if zg >= zd + min_price_overlap
                        // 检查当前笔是否已被之前的中枢完全覆盖
                        // 同级别分解：只检查起始笔是否被覆盖，允许共享边界笔
                        bool is_covered = false
                        if array.size(pen_centers) > 0
                            for k = 0 to array.size(pen_centers) - 1
                                existing = array.get(pen_centers, k)
                                // 只有当起始笔被前一个中枢内部包含时才算被覆盖
                                // 允许 i+1 == existing.end_pen_idx（共享边界笔）
                                if i + 1 > existing.start_pen_idx and i + 1 < existing.end_pen_idx
                                    is_covered := true
                                    break

                        if not is_covered
                            // GG = 中枢组件中的最高点
                            float center_gg = math.max(pen1.high, math.max(pen2.high, pen3.high))
                            // DD = 中枢组件中的最低点
                            float center_dd = math.min(pen1.low, math.min(pen2.low, pen3.low))
                            int end_idx = i + 3

                            // 尝试延伸中枢（只有当有更多笔时才尝试）
                            if i + 4 < pen_count
                                for j = i + 4 to pen_count - 1
                                    ext_pen = array.get(pens, j)
                                    bool enters_zs = ext_pen.high >= zd and ext_pen.low <= zg
                                    if enters_zs
                                        float new_zg = math.min(zg, ext_pen.high)
                                        float new_zd = math.max(zd, ext_pen.low)
                                        if new_zg >= new_zd + min_price_overlap
                                            zg := new_zg
                                            zd := new_zd
                                            end_idx := j
                                            center_gg := math.max(center_gg, ext_pen.high)
                                            center_dd := math.min(center_dd, ext_pen.low)
                                        else
                                            break
                                    else
                                        break

                            bool is_closed = end_idx + 1 < pen_count

                            first_pen = array.get(pens, i + 1)
                            last_pen = array.get(pens, end_idx)
                            float center_mid = (zg + zd) / 2

                            box new_box = na
                            if show_pen_center
                                new_box := box.new(left = first_pen.start_time, top = zg, right = last_pen.end_time, bottom = zd,
                                     bgcolor = PEN_CENTER_COLOR, border_color = PEN_COLOR, border_width = 1, xloc = xloc.bar_time)

                            array.push(pen_centers, PenCenter.new(zg, zd, center_gg, center_dd, center_mid, first_pen.start_time, last_pen.end_time,
                                 i + 1, end_idx, new_box, is_closed, center_dir, false, 1, false, 0.0))

                            // 同级别分解关键修改：
                            // 允许下一个中枢从当前中枢的倒数第2笔开始（共享边界笔）
                            if end_idx > i + 3
                                // 中枢被延伸了，从倒数第2笔开始寻找下一个中枢
                                i := end_idx - 2
                            else
                                // 标准4笔结构（进入笔+3笔中枢），从中枢第2笔开始寻找下一个中枢
                                i := i + 1
                        else
                            i := i + 1
                    else
                        i := i + 1
                else
                    i := i + 1

    // 注意：已移除中枢合并和扩展逻辑
    // 同级别分解中,每个中枢独立存在,不进行合并或扩展
    true

// === 中枢检测与构建 ===
// 使用笔作为次级别构建中枢（同级别分解）
check_and_build_centers() =>
    // 清理所有现有中枢
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)

    // 注意：不在这里清理交易信号！
    // 交易信号的清理和重新生成只在 barstate.islast 中进行
    // 如果在这里清理，每次新笔产生时都会清空买卖点，但不会立即重新生成

    // 使用笔作为次级别构建中枢
    build_pen_centers()
    true

// === 清理函数（笔变化时调用）===
cleanup_after_pen_change() =>
    // 注意：只清理中枢，不清理买卖点信号！
    // 买卖点信号的清理只在 barstate.islast 中进行
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)
    true

// === 性能优化 ===
// 使用缓存变量避免重复计算
var int last_calculated_bar = 0
var bool needs_recalculate = true
var int last_pen_count = 0
var int last_center_count = 0

// 检查是否需要重新计算
if bar_index != last_calculated_bar
    needs_recalculate := true
    last_calculated_bar := bar_index
else
    needs_recalculate := false

// 限制历史数据大小
MAX_HISTORY = 1000
if array.size(pens) > MAX_HISTORY
    pens := array.slice(pens, array.size(pens) - MAX_HISTORY, array.size(pens))
if array.size(pen_centers) > MAX_HISTORY / 10
    pen_centers := array.slice(pen_centers, array.size(pen_centers) - MAX_HISTORY / 10, array.size(pen_centers))

// === 主流程 ===
// 存储当前bar的MACD值
array.push(macd_hist_array, macd_hist)

// 限制MACD历史数组大小
if array.size(macd_hist_array) > MAX_HISTORY * 10
    macd_hist_array := array.slice(macd_hist_array, array.size(macd_hist_array) - MAX_HISTORY * 10, array.size(macd_hist_array))

// 初始化current_kx（处理历史K线）
if not current_kx_initialized
    current_kx := Kx.new(high, low, time, -1, bar_index)
    current_kx_initialized := true
else
    bool has_include = (high >= current_kx.high and low <= current_kx.low) or
                       (high <= current_kx.high and low >= current_kx.low)

    if has_include
        // 包含关系处理
        if array.size(kx_array) >= 1
            prev_kx = array.last(kx_array)
            bool uptrend = high > prev_kx.high or low > prev_kx.low

            if uptrend
                current_kx.high := math.max(high, current_kx.high)
                current_kx.low := math.max(low, current_kx.low)
            else
                current_kx.high := math.min(high, current_kx.high)
                current_kx.low := math.min(low, current_kx.low)
        else
            current_kx.high := math.max(high, current_kx.high)
            current_kx.low := math.min(low, current_kx.low)

        current_kx.time := time
        current_kx.bar_idx := bar_index
    else
        // 无包含，完成当前K线
        current_kx.index := array.size(kx_array)
        array.push(kx_array, current_kx)

        // 分型检测（需要至少3根合并K线）
        if array.size(kx_array) >= 3
            k1 = array.get(kx_array, array.size(kx_array) - 3)
            k2 = array.get(kx_array, array.size(kx_array) - 2)
            k3 = array.get(kx_array, array.size(kx_array) - 1)

            is_top = k2.high > k1.high and k2.high > k3.high and
                     k2.low > k1.low and k2.low > k3.low
            is_bot = k2.low < k1.low and k2.low < k3.low and
                     k2.high < k1.high and k2.high < k3.high

            if is_top or is_bot
                new_price = is_top ? k2.high : k2.low
                new_time = k2.time
                new_type = is_top ? 1 : -1
                new_kx_index = k2.index
                new_bar_idx = k2.bar_idx

                // 确认前一个分型（分型确认需等待第4根K线）
                if array.size(pen_fractals) > 0
                    last_fx = array.last(pen_fractals)
                    if not last_fx.confirmed
                        last_fx.confirmed := true

                if array.size(pen_fractals) == 0
                    // 第一个分型
                    label lbl = na
                    if show_fractal_labels
                        lbl := label.new(
                             x = new_time,
                             y = new_price,
                             text = is_top ? '顶' : '底',
                             color = PEN_COLOR,
                             textcolor = color.white,
                             xloc = xloc.bar_time,
                             size = size.tiny)
                    array.push(pen_fractals, Fx.new(
                         new_price,
                         k2.high,
                         k2.low,
                         new_time,
                         new_type,
                         lbl,
                         new_kx_index,
                         new_bar_idx,
                         false))
                else
                    lastfx = array.last(pen_fractals)

                    if new_type != lastfx.type
                        // 不同类型分型，尝试构建笔
                        bool is_valid = false
                        int kx_gap = new_kx_index - lastfx.kx_index

                        if pen_algo == '新笔/严格笔'
                            if new_type == 1
                                is_valid := kx_gap >= 2 and k2.low > lastfx.fx_high
                            else
                                is_valid := kx_gap >= 2 and k2.high < lastfx.fx_low
                        else
                            is_valid := kx_gap >= 2

                        // 检查笔的最小K线数（加入缺口计数）
                        int effective_kx_count = kx_gap + 1 + count_gaps_between(lastfx.kx_index, new_kx_index)

                        // 检查笔端点是否是极值
                        bool is_peak = check_end_is_peak(lastfx.kx_index, new_kx_index, new_type == 1)

                        if is_valid and effective_kx_count >= min_pen_bars and is_peak
                            label lbl2 = na
                            if show_fractal_labels
                                lbl2 := label.new(
                                     x = new_time,
                                     y = new_price,
                                     text = is_top ? '顶' : '底',
                                     color = PEN_COLOR,
                                     textcolor = color.white,
                                     xloc = xloc.bar_time,
                                     size = size.tiny)

                            // 确认上一个分型
                            lastfx.confirmed := true

                            array.push(pen_fractals, Fx.new(
                                 new_price,
                                 k2.high,
                                 k2.low,
                                 new_time,
                                 new_type,
                                 lbl2,
                                 new_kx_index,
                                 new_bar_idx,
                                 false))

                            // 计算笔的MACD面积
                            float pen_macd_area = calc_macd_area(lastfx.bar_idx, new_bar_idx, new_type)

                            // 计算笔的属性
                            int pen_kx_count = kx_gap + 1
                            float pen_amplitude = math.abs(new_price - lastfx.price)
                            float pen_slope = pen_kx_count > 0 ? pen_amplitude / pen_kx_count : 0

                            // 确认前一笔（如果存在）
                            if array.size(pens) > 0
                                prev_pen = array.last(pens)
                                prev_pen.confirmed := true
                                // 将已确认的笔改为实线
                                if array.size(pen_lines) > 0
                                    line.set_style(array.get(pen_lines, array.size(pen_lines) - 1), line.style_solid)

                            // 画笔线
                            line_color = new_type == 1 ? PEN_UP_COLOR : PEN_DOWN_COLOR
                            // 新笔默认未确认，使用虚线
                            line_style = line.style_dashed
                            pline = line.new(
                                 x1 = lastfx.time,
                                 y1 = lastfx.price,
                                 x2 = new_time,
                                 y2 = new_price,
                                 color = line_color,
                                 width = PEN_WIDTH,
                                 style = line_style,
                                 xloc = xloc.bar_time)
                            array.push(pen_lines, pline)

                            // 创建笔
                            array.push(pens, Pen.new(
                                 start_fx_idx = array.size(pen_fractals) - 2,
                                 end_fx_idx = array.size(pen_fractals) - 1,
                                 high = math.max(lastfx.price, new_price),
                                 low = math.min(lastfx.price, new_price),
                                 direction = new_type,  // direction: 1=向上, -1=向下
                                 start_time = lastfx.time,
                                 end_time = new_time,
                                 start_bar_idx = lastfx.bar_idx,
                                 end_bar_idx = new_bar_idx,
                                 macd_area = pen_macd_area,
                                 confirmed = false,  // 新笔未确认
                                 kx_count = pen_kx_count,
                                 amplitude = pen_amplitude,
                                 slope = pen_slope))

                            // 重新计算所有中枢和买卖点
                            check_and_build_centers()
                    else
                        // 同类型分型，检查是否需要延伸
                        bool should_replace = false
                        if new_type == 1
                            should_replace := new_price > lastfx.price
                        else
                            should_replace := new_price < lastfx.price

                        if should_replace
                            // 删除旧分型标签
                            if not na(lastfx.label_id)
                                label.delete(lastfx.label_id)

                            // 删除对应的笔线和笔
                            if array.size(pen_lines) > 0
                                line.delete(array.pop(pen_lines))
                            if array.size(pens) > 0
                                array.pop(pens)
                                cleanup_after_pen_change()

                            array.pop(pen_fractals)

                            // 创建新分型
                            label lbl3 = na
                            if show_fractal_labels
                                lbl3 := label.new(
                                     x = new_time,
                                     y = new_price,
                                     text = is_top ? '顶' : '底',
                                     color = PEN_COLOR,
                                     textcolor = color.white,
                                     xloc = xloc.bar_time,
                                     size = size.tiny)

                            array.push(pen_fractals, Fx.new(
                                 new_price,
                                 k2.high,
                                 k2.low,
                                 new_time,
                                 new_type,
                                 lbl3,
                                 new_kx_index,
                                 new_bar_idx,
                                 false))

                            // 重新创建笔
                            if array.size(pen_fractals) > 1
                                prevfx = array.get(pen_fractals, array.size(pen_fractals) - 2)
                                float pen_macd_area2 = calc_macd_area(prevfx.bar_idx, new_bar_idx, new_type)

                                // 计算笔的属性
                                int pen_kx_count2 = new_kx_index - prevfx.kx_index + 1
                                float pen_amplitude2 = math.abs(new_price - prevfx.price)
                                float pen_slope2 = pen_kx_count2 > 0 ? pen_amplitude2 / pen_kx_count2 : 0

                                line_color = new_type == 1 ? PEN_UP_COLOR : PEN_DOWN_COLOR
                                // 延伸的笔使用虚线（因为还未确认）
                                line_style = line.style_dashed
                                pline2 = line.new(
                                     x1 = prevfx.time,
                                     y1 = prevfx.price,
                                     x2 = new_time,
                                     y2 = new_price,
                                     color = line_color,
                                     width = PEN_WIDTH,
                                     style = line_style,
                                     xloc = xloc.bar_time)
                                array.push(pen_lines, pline2)

                                array.push(pens, Pen.new(
                                     start_fx_idx = array.size(pen_fractals) - 2,
                                     end_fx_idx = array.size(pen_fractals) - 1,
                                     high = math.max(prevfx.price, new_price),
                                     low = math.min(prevfx.price, new_price),
                                     direction = new_type,
                                     start_time = prevfx.time,
                                     end_time = new_time,
                                     start_bar_idx = prevfx.bar_idx,
                                     end_bar_idx = new_bar_idx,
                                     macd_area = pen_macd_area2,
                                     confirmed = false,
                                     kx_count = pen_kx_count2,
                                     amplitude = pen_amplitude2,
                                     slope = pen_slope2))

                                // 重新计算所有中枢和买卖点
                                check_and_build_centers()

        // 开始新的合并K线
        current_kx := Kx.new(high, low, time, -1, bar_index)

// === 处理买卖点信号 ===
if barstate.islast
    pen_count = array.size(pens)

    // 清理旧的交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)

    // 重置状态
    last_buy1_pen_idx := na
    last_buy1_price := na
    last_sell1_pen_idx := na
    last_sell1_price := na

    // 从头开始扫描所有已确认的笔
    if pen_count >= 3
        for i = 2 to pen_count - 1
            pen = array.get(pens, i)

            if pen.confirmed and bsp_enabled
                // 检查1买
                bool check_type_1 = should_check_bsp_type(1)
                if check_type_1
                    [buy1_triggered, new_buy1_idx, new_buy1_price, buy1_type] = check_buy1(i, last_buy1_pen_idx, last_buy1_price)
                    if buy1_triggered
                        last_buy1_pen_idx := new_buy1_idx
                        last_buy1_price := new_buy1_price
                        end_fx = array.get(pen_fractals, pen.end_fx_idx)

                        // 重新获取笔的信息用于生成tooltip
                        pen3 = array.get(pens, i)

                        // 获取最后一个中枢信息
                        PenCenter last_center = array.get(pen_centers, array.size(pen_centers) - 1)

                        // 生成详细的tooltip
                        string tooltip = "【1买】" + "\n" +
                                       "\n" +
                                       "缠论定义: 某级别下跌趋势中，一个次级别走势类型向下跌破最后一个缠中说禅走势中枢后形成的背驰点" + "\n" +
                                       "\n" +
                                       "生成条件:" + "\n" +
                                       "• 跌破最后一个中枢下沿(ZD): " + str.tostring(math.round(last_center.low, 2)) + "\n" +
                                       "• 当前低点: " + str.tostring(math.round(pen3.low, 2)) + "\n" +
                                       "• MACD面积: " + str.tostring(math.round(pen3.macd_area, 4)) + "\n" +
                                       "• 笔力度: " + str.tostring(math.round(pen3.slope, 4))

                        label lb = add_trade_signal_label(end_fx.time, end_fx.price, "1买", 1, tooltip)
                        array.push(trade_signals, TradeSignal.new(1, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, array.size(pen_centers) - 1, "第一类买点", lb))

                // 检查1卖
                if check_type_1
                    [sell1_triggered, new_sell1_idx, new_sell1_price, sell1_type] = check_sell1(i, last_sell1_pen_idx, last_sell1_price)
                    if sell1_triggered
                        last_sell1_pen_idx := new_sell1_idx
                        last_sell1_price := new_sell1_price
                        end_fx = array.get(pen_fractals, pen.end_fx_idx)

                        // 重新获取笔的信息用于生成tooltip
                        pen3 = array.get(pens, i)

                        // 获取最后一个中枢信息
                        PenCenter last_center = array.get(pen_centers, array.size(pen_centers) - 1)

                        // 生成详细的tooltip
                        string tooltip = "【1卖】" + "\n" +
                                       "\n" +
                                       "缠论定义: 某级别上涨趋势中，一个次级别走势类型向上突破最后一个缠中说禅走势中枢后形成的背驰点" + "\n" +
                                       "\n" +
                                       "生成条件:" + "\n" +
                                       "• 突破最后一个中枢上沿(ZG): " + str.tostring(math.round(last_center.high, 2)) + "\n" +
                                       "• 当前高点: " + str.tostring(math.round(pen3.high, 2)) + "\n" +
                                       "• MACD面积: " + str.tostring(math.round(pen3.macd_area, 4)) + "\n" +
                                       "• 笔力度: " + str.tostring(math.round(pen3.slope, 4))

                        label lb = add_trade_signal_label(end_fx.time, end_fx.price, "1卖", -1, tooltip)
                        array.push(trade_signals, TradeSignal.new(-1, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, array.size(pen_centers) - 1, "第一类卖点", lb))

                // 检查2买
                bool check_type_2 = should_check_bsp_type(2)
                if check_type_2
                    [buy2_triggered, buy2_type] = check_buy2(i, last_buy1_pen_idx, last_buy1_price)
                    if buy2_triggered
                        end_fx = array.get(pen_fractals, pen.end_fx_idx)
                        pen := array.get(pens, i)

                        // 生成详细的tooltip
                        string tooltip = "【2买】" + "\n" +
                                       "\n" +
                                       "缠论定义: 某级别中，第一类买点的次级别上涨结束后再次下跌的那个次级别走势类型的结束点" + "\n" +
                                       "\n" +
                                       "生成条件:" + "\n" +
                                       "• 前提: 已确认1买信号" + "\n" +
                                       "• 1买位置: " + str.tostring(math.round(last_buy1_price, 2)) + "\n" +
                                       "• 当前位置: " + str.tostring(math.round(pen.low, 2)) + "\n" +
                                       "• 支撑有效: " + (pen.low >= last_buy1_price ? "是" : "否")

                        label lb = add_trade_signal_label(end_fx.time, end_fx.price, "2买", 1, tooltip)
                        array.push(trade_signals, TradeSignal.new(2, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, "第二类买点", lb))

                // 检查2卖
                if check_type_2
                    [sell2_triggered, sell2_type] = check_sell2(i, last_sell1_pen_idx, last_sell1_price)
                    if sell2_triggered
                        end_fx = array.get(pen_fractals, pen.end_fx_idx)
                        pen := array.get(pens, i)

                        // 生成详细的tooltip
                        string tooltip = "【2卖】" + "\n" +
                                       "\n" +
                                       "缠论定义: 某级别中，第一类卖点的次级别下跌结束后再次上涨的那个次级别走势类型的结束点" + "\n" +
                                       "\n" +
                                       "生成条件:" + "\n" +
                                       "• 前提: 已确认1卖信号" + "\n" +
                                       "• 1卖位置: " + str.tostring(math.round(last_sell1_price, 2)) + "\n" +
                                       "• 当前位置: " + str.tostring(math.round(pen.high, 2)) + "\n" +
                                       "• 阻力有效: " + (pen.high <= last_sell1_price ? "是" : "否")

                        label lb = add_trade_signal_label(end_fx.time, end_fx.price, "2卖", -1, tooltip)
                        array.push(trade_signals, TradeSignal.new(-2, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, "第二类卖点", lb))

                // 检查3买
                bool check_type_3 = should_check_bsp_type(3)
                if check_type_3 and check_buy3(i)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    pen := array.get(pens, i)

                    // 查找相关的中枢
                    int ref_center_idx = na
                    PenCenter ref_center = na
                    if array.size(pen_centers) > 0
                        for j = array.size(pen_centers) - 1 to 0
                            center = array.get(pen_centers, j)
                            if center.direction == 1 and center.closed and i > center.end_pen_idx + 1
                                // 检查是否有向上突破笔
                                int exit_pen_idx = center.end_pen_idx + 1
                                if exit_pen_idx < array.size(pens)
                                    exit_pen = array.get(pens, exit_pen_idx)
                                    if exit_pen.direction == 1 and exit_pen.high > center.high
                                        if i > exit_pen_idx and pen.low > center.high
                                            ref_center_idx := j
                                            ref_center := center
                                            break

                    // 生成详细的tooltip
                    string tooltip = "【3买】" + "\n" +
                                   "\n" +
                                   "缠论定义: 一个次级别走势类型向上离开缠中说禅走势中枢，然后以一个次级别走势类型回试，其低点不跌破ZG，则构成第三类买点" + "\n" +
                                   "\n" +
                                   "生成条件:" + "\n" +
                                   "• 前提: 存在上涨中枢" + "\n" +
                                   "• 结构: 突破中枢后回抽不入中枢" + "\n" +
                                   "• 当前位置: " + str.tostring(math.round(pen.low, 2)) + "\n"

                    if not na(ref_center)
                        tooltip := tooltip + "\n" +
                                   "中枢信息:" + "\n" +
                                   "• 中枢上沿(ZG): " + str.tostring(math.round(ref_center.high, 2)) + "\n" +
                                   "• 中枢下沿(ZD): " + str.tostring(math.round(ref_center.low, 2)) + "\n" +
                                   "• 中枢中轴: " + str.tostring(math.round(ref_center.mid, 2)) + "\n" +
                                   "• 回抽低点距离中枢: " + str.tostring(math.round(pen.low - ref_center.high, 2))

                    label lb = add_trade_signal_label(end_fx.time, end_fx.price, "3买", 1, tooltip)
                    array.push(trade_signals, TradeSignal.new(3, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, ref_center_idx, "第三类买点", lb))

                // 检查3卖
                if check_type_3 and check_sell3(i)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    pen := array.get(pens, i)

                    // 查找相关的中枢
                    int ref_center_idx = na
                    PenCenter ref_center = na
                    if array.size(pen_centers) > 0
                        for j = array.size(pen_centers) - 1 to 0
                            center = array.get(pen_centers, j)
                            if center.direction == -1 and center.closed and i > center.end_pen_idx + 1
                                // 检查是否有向下跌破笔
                                int exit_pen_idx = center.end_pen_idx + 1
                                if exit_pen_idx < array.size(pens)
                                    exit_pen = array.get(pens, exit_pen_idx)
                                    if exit_pen.direction == -1 and exit_pen.low < center.low
                                        if i > exit_pen_idx and pen.high < center.low
                                            ref_center_idx := j
                                            ref_center := center
                                            break

                    // 生成详细的tooltip
                    string tooltip = "【3卖】" + "\n" +
                                   "\n" +
                                   "缠论定义: 一个次级别走势类型向下离开缠中说禅走势中枢，然后以一个次级别走势类型回试，其高点不升破ZD，则构成第三类卖点" + "\n" +
                                   "\n" +
                                   "生成条件:" + "\n" +
                                   "• 前提: 存在下跌中枢" + "\n" +
                                   "• 结构: 跌破中枢后反弹不入中枢" + "\n" +
                                   "• 当前位置: " + str.tostring(math.round(pen.high, 2)) + "\n"

                    if not na(ref_center)
                        tooltip := tooltip + "\n" +
                                   "中枢信息:" + "\n" +
                                   "• 中枢上沿(ZG): " + str.tostring(math.round(ref_center.high, 2)) + "\n" +
                                   "• 中枢下沿(ZD): " + str.tostring(math.round(ref_center.low, 2)) + "\n" +
                                   "• 中枢中轴: " + str.tostring(math.round(ref_center.mid, 2)) + "\n" +
                                   "• 反弹高点距离中枢: " + str.tostring(math.round(ref_center.low - pen.high, 2))

                    label lb = add_trade_signal_label(end_fx.time, end_fx.price, "3卖", -1, tooltip)
                    array.push(trade_signals, TradeSignal.new(-3, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, ref_center_idx, "第三类卖点", lb))

    // 显示背驰信号（已注释 - 背驰信息会显示在1买/1卖的tooltip中）
    // if show_divergence_signals and pen_count >= 3
    //     for i = math.max(2, pen_count - 5) to pen_count - 1
    //         pen = array.get(pens, i)
    //         if pen.confirmed
    //             [has_div, area_cur, area_prev] = detect_bi_divergence(i)
    //             if has_div
    //                 end_fx = array.get(pen_fractals, pen.end_fx_idx)
    //                 div_text = pen.direction == 1 ? "顶背驰" : "底背驰"
    //                 div_color = pen.direction == 1 ? color.red : color.green
    //
    //                 // 检查是否已有该背驰的1买/1卖标签
    //                 bool label_exists = false
    //                 for j = 0 to array.size(trade_signals) - 1
    //                     sig = array.get(trade_signals, j)
    //                     if sig.ref_pen_idx == i and (sig.type == 1 or sig.type == -1)
    //                         label_exists := true
    //                         break
    //
    //                 if not label_exists
    //                     // 显示背驰标签（独立于买卖点）
    //                     label.new(
    //                          x = end_fx.time,
    //                          y = pen.direction == 1 ? pen.high * 1.001 : pen.low * 0.999,
    //                          text = div_text,
    //                          color = div_color,
    //                          textcolor = color.white,
    //                          style = pen.direction == 1 ? label.style_label_down : label.style_label_up,
    //                          size = size.tiny,
    //                          xloc = xloc.bar_time)

// === 辅助图表 ===
plot(close, title = "helper", color = color.new(color.gray, 100), linewidth = 1)

// === 信息表格 (白色主题) ===
var table info_table = table.new(position.top_right, 2, 20, bgcolor = #ffffff, border_width = 1, border_color = #e0e0e0)
if barstate.islast
    // 白色主题颜色配置
    color title_bg = #f5f5f5      // 浅灰背景
    color value_bg = #ffffff      // 白色背景
    color title_text = #333333    // 深灰标题文字
    color value_text = #1976d2    // 蓝色数值
    color highlight_text = #00897b // 绿色高亮
    color warning_text = #d32f2f   // 红色警告
    color on_text = #4caf50       // 开启状态
    color off_text = #9e9e9e      // 关闭状态
    color level_text = #e65100    // 橙色级别文字

    // === 同级别分解信息（实战最重要）===
    string current_level = get_current_level()
    string sub_level = get_sub_level(current_level)
    string trend_type = get_current_trend_type()

    table.cell(info_table, 0, 0, "当前级别", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 0, current_level, text_color = level_text, bgcolor = value_bg, text_size = size.normal)
    table.cell(info_table, 0, 1, "次级别", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 1, sub_level, text_color = value_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 2, "走势类型", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    color trend_color = trend_type == "上涨" or trend_type == "上涨趋势" ? on_text :
                       trend_type == "下跌" or trend_type == "下跌趋势" ? warning_text : value_text
    table.cell(info_table, 1, 2, trend_type, text_color = trend_color, bgcolor = value_bg, text_size = size.small)

    // 基础统计
    table.cell(info_table, 0, 3, "合并K线", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 3, str.tostring(array.size(kx_array)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 4, "分型数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 4, str.tostring(array.size(pen_fractals)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 5, "笔数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 5, str.tostring(array.size(pens)), text_color = highlight_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 6, "中枢数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 6, str.tostring(array.size(pen_centers)), text_color = highlight_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 7, "买卖点", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 7, str.tostring(array.size(trade_signals)), text_color = #f57c00, bgcolor = value_bg, text_size = size.small)

    // 算法设置
    table.cell(info_table, 0, 8, "笔算法", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 8, pen_algo, text_color = #7b1fa2, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 9, "中枢算法", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 9, zs_algo, text_color = #7b1fa2, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 10, "最小K线", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 10, str.tostring(min_pen_bars), text_color = value_text, bgcolor = value_bg, text_size = size.small)

    // 功能开关
    table.cell(info_table, 0, 11, "缺口算K", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 11, gap_as_kl ? "✓" : "✗", text_color = gap_as_kl ? on_text : off_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 12, "端点极值", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 12, bi_end_is_peak ? "✓" : "✗", text_color = bi_end_is_peak ? on_text : off_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 13, "买卖点类型", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 13, bsp_types, text_color = #7b1fa2, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 14, "严格3类", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 14, bsp_strict_3 ? "✓" : "✗", text_color = bsp_strict_3 ? on_text : off_text, bgcolor = value_bg, text_size = size.small)

    // 最新信号
    if array.size(trade_signals) > 0
        latest_sig = array.get(trade_signals, array.size(trade_signals) - 1)
        string sig_name = ""
        if latest_sig.type == 1
            sig_name := "1买"
        else if latest_sig.type == -1
            sig_name := "1卖"
        else if latest_sig.type == 2
            sig_name := "2买"
        else if latest_sig.type == -2
            sig_name := "2卖"
        else if latest_sig.type == 3
            sig_name := "3买"
        else if latest_sig.type == -3
            sig_name := "3卖"

        table.cell(info_table, 0, 15, "最新信号", text_color = title_text, bgcolor = title_bg, text_size = size.small)
        table.cell(info_table, 1, 15, sig_name, text_color = latest_sig.type > 0 ? on_text : warning_text, bgcolor = value_bg, text_size = size.small)


// === 最终绘制管理 ===
// 按优先级管理所有绘图对象
if barstate.islast
    draw_by_priority()
