//@version=6
indicator('缠论自动画笔中枢 (Chanlun Auto)', '缠论笔中枢', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// === 用户参数 ===
pen_algo = input.string('老笔', title = '画笔算法', options = ['老笔', '新笔/严格笔'])
show_pen_center = input.bool(true, title = '显示笔中枢')
show_fractal_labels = input.bool(false, title = '显示顶底分型标签')
show_divergence_signals = input.bool(true, title = '显示背驰买卖标记')
show_trade_signals = input.bool(true, title = '显示1/2/3买卖点')
divergence_ratio = input.float(0.7, title = 'MACD力度减弱比例(<=该值判背驰)', minval = 0.1, maxval = 1.0, step = 0.05)
min_price_overlap_input = input.float(1.0, title = "中枢最小价格重叠", step = 0.5)
min_price_overlap = min_price_overlap_input * syminfo.mintick

// === 颜色 ===
PEN_COLOR = color.new(color.blue, 0)
PEN_CENTER_COLOR = color.new(color.blue, 80)
PEN_WIDTH = 2

// === 类型定义 ===
type Kx
    float high
    float low
    int time
    int index
    int bar_index

type Fx
    float price
    float fx_high
    float fx_low
    int time
    int type
    label label_id
    int kx_index

type Pen
    int start_fx_idx
    int end_fx_idx
    float high
    float low
    int direction
    int start_time
    int end_time
    float strength

type PenCenter
    float high
    float low
    int start_time
    int end_time
    int start_pen_idx
    int end_pen_idx
    box box_id
    bool divergence
    int exit_pen_idx
    label signal_label

// === 全局 ===
var kx_array = array.new<Kx>()
var pen_fractals = array.new<Fx>()
var pen_lines = array.new<line>()
var pens = array.new<Pen>()
var pen_centers = array.new<PenCenter>()
var signal_labels = array.new<label>()
var trade_labels = array.new<label>()
var Kx current_kx = na

// === 交易点状态 ===
var int pending_div_dir = na
var float pending_div_price = na
var int pending_div_center_idx = na
var float last_buy1_low = na
var float last_sell1_high = na
var float pullback_low_after_buy1 = na
var float pullback_high_after_sell1 = na
var float last_center_high = na
var float last_center_low = na
var int last_center_exit_dir = na
var bool ready_buy3 = false
var bool ready_sell3 = false

// === 辅助函数 ===
safe_delete_box(b) =>
    if not na(b)
        box.delete(b)

safe_delete_label(l) =>
    if not na(l)
        label.delete(l)

add_trade_label(t, price, text, dir) =>
    if show_trade_signals
        color c = dir == 1 ? color.red : color.green
        label.style s = dir == 1 ? label.style_label_down : label.style_label_up
        label lb = label.new(
             x = t,
             y = price,
             text = text,
             color = c,
             textcolor = color.white,
             style = s,
             xloc = xloc.bar_time)
        array.push(trade_labels, lb)

get_pen_strength() =>
    // 计算笔力度指标，用于背驰判定（固定 MACD 柱）
    [macd, signal, hist] = ta.macd(close, 12, 26, 9)
    hist

detect_pen_divergence(exit_pen_idx, start_pen_idx) =>
    // 以离开中枢的笔与此前同方向笔比较：价格创新高/低但力度减弱
    bool has_div = false
    if exit_pen_idx < array.size(pens) and start_pen_idx >= 0
        exit_pen = array.get(pens, exit_pen_idx)
        int prev_idx = na
        for p = exit_pen_idx - 1 downto start_pen_idx
            prior = array.get(pens, p)
            if prior.direction == exit_pen.direction
                prev_idx := p
                break
        if not na(prev_idx)
            prior_pen = array.get(pens, prev_idx)
            bool price_new = exit_pen.direction == 1 ? exit_pen.high > prior_pen.high : exit_pen.low < prior_pen.low
            bool strength_weaker = math.abs(exit_pen.strength) < math.abs(prior_pen.strength) * divergence_ratio
            has_div := price_new and strength_weaker
    has_div

process_trade_points(new_type, new_price, new_time) =>
    // 1买/1卖：背驰后等待反向分型确认
    if not na(pending_div_dir) and new_type != pending_div_dir
        if pending_div_dir == -1
            add_trade_label(new_time, new_price, '1B', -1)
            last_buy1_low := new_price
            pullback_low_after_buy1 := na
        else
            add_trade_label(new_time, new_price, '1S', 1)
            last_sell1_high := new_price
            pullback_high_after_sell1 := na
        pending_div_dir := na
        pending_div_price := na
        pending_div_center_idx := na
    
    // 记录1买后的回踩低点，用于2买
    if not na(last_buy1_low)
        if new_type == -1
            pullback_low_after_buy1 := na(pullback_low_after_buy1) ? new_price : math.min(pullback_low_after_buy1, new_price)
        if new_type == 1 and not na(pullback_low_after_buy1) and pullback_low_after_buy1 >= last_buy1_low
            add_trade_label(new_time, new_price, '2B', -1)
            pullback_low_after_buy1 := na
    
    // 记录1卖后的回抽高点，用于2卖
    if not na(last_sell1_high)
        if new_type == 1
            pullback_high_after_sell1 := na(pullback_high_after_sell1) ? new_price : math.max(pullback_high_after_sell1, new_price)
        if new_type == -1 and not na(pullback_high_after_sell1) and pullback_high_after_sell1 <= last_sell1_high
            add_trade_label(new_time, new_price, '2S', 1)
            pullback_high_after_sell1 := na
    
    // 3买：上离开中枢后回踩不入内，出现向上分型
    if not na(last_center_exit_dir) and last_center_exit_dir == 1 and not na(last_center_high)
        if new_type == -1 and new_price >= last_center_high
            ready_buy3 := true
        if new_type == 1 and ready_buy3
            add_trade_label(new_time, new_price, '3B', -1)
            ready_buy3 := false
    
    // 3卖：下离开中枢后回抽不入内，出现向下分型
    if not na(last_center_exit_dir) and last_center_exit_dir == -1 and not na(last_center_low)
        if new_type == 1 and new_price <= last_center_low
            ready_sell3 := true
        if new_type == -1 and ready_sell3
            add_trade_label(new_time, new_price, '3S', 1)
            ready_sell3 := false

// === 核心:计算多笔的真实重叠区间 ===
get_pens_overlap(pen_indices) =>
    if array.size(pen_indices) < 3
        [na, na]
    else
        first_idx = array.get(pen_indices, 0)
        first_pen = array.get(pens, first_idx)
        float overlap_high = first_pen.high
        float overlap_low = first_pen.low
        
        bool has_valid_overlap = true
        for i = 1 to array.size(pen_indices) - 1
            pen_idx = array.get(pen_indices, i)
            pen = array.get(pens, pen_idx)
            
            float new_low = math.max(overlap_low, pen.low)
            float new_high = math.min(overlap_high, pen.high)
            
            if new_high <= new_low or (new_high - new_low) < min_price_overlap
                has_valid_overlap := false
                break
            
            overlap_high := new_high
            overlap_low := new_low
        
        if has_valid_overlap and overlap_high > overlap_low
            [overlap_high, overlap_low]
        else
            [na, na]

// === 完全重写中枢检测逻辑 ===
check_and_add_center() =>
    pen_count = array.size(pens)
    
    // 第一步:删除所有现有中枢,重新计算
    // 这样可以确保中枢始终基于当前笔序列的最新状态
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
            safe_delete_label(center.signal_label)
        array.clear(pen_centers)
    
    // 清理旧信号标签
    if array.size(signal_labels) > 0
        for i = 0 to array.size(signal_labels) - 1
            safe_delete_label(array.get(signal_labels, i))
        array.clear(signal_labels)
    if array.size(trade_labels) > 0
        for i = 0 to array.size(trade_labels) - 1
            safe_delete_label(array.get(trade_labels, i))
        array.clear(trade_labels)
    pending_div_dir := na
    pending_div_price := na
    pending_div_center_idx := na
    pullback_low_after_buy1 := na
    pullback_high_after_sell1 := na
    ready_buy3 := false
    ready_sell3 := false
    if array.size(trade_labels) > 0
        for i = 0 to array.size(trade_labels) - 1
            safe_delete_label(array.get(trade_labels, i))
        array.clear(trade_labels)
    
    // 第二步:只有至少5笔时才检测中枢
    if pen_count >= 5
        // 从最早的笔开始扫描,寻找所有可能的中枢
        // 中枢结构: 笔i(进入) + 笔i+1,i+2,i+3(中枢内部3笔) + 笔i+4(离开)
        
        int i = 0
        while i <= pen_count - 5
            // 尝试从位置i开始构建中枢
            // 中枢内部笔: i+1, i+2, i+3
            pen_indices = array.new<int>()
            array.push(pen_indices, i + 1)
            array.push(pen_indices, i + 2)
            array.push(pen_indices, i + 3)
            
            // 计算这3笔的重叠区间
            [overlap_h, overlap_l] = get_pens_overlap(pen_indices)
            
            // 如果有有效重叠
            if not na(overlap_h) and not na(overlap_l)
                // 检查这个中枢是否已经被之前识别的中枢覆盖
                bool is_covered = false
                if array.size(pen_centers) > 0
                    for k = 0 to array.size(pen_centers) - 1
                        existing = array.get(pen_centers, k)
                        // 如果新中枢的起始笔在已有中枢范围内,跳过
                        if i + 1 >= existing.start_pen_idx and i + 1 <= existing.end_pen_idx
                            is_covered := true
                            break
                
                if not is_covered
                    // 尝试延伸中枢:检查后续笔是否能扩展中枢
                    int end_idx = i + 3
                    
                    // 向后扫描,尝试将更多笔纳入中枢
                    // 但必须保证最后至少留1笔作为离开笔
                    for j = i + 4 to pen_count - 2
                        extended_indices = array.new<int>()
                        for m = i + 1 to j
                            array.push(extended_indices, m)
                        
                        [ext_overlap_h, ext_overlap_l] = get_pens_overlap(extended_indices)
                        
                        if not na(ext_overlap_h) and not na(ext_overlap_l)
                            // 可以延伸
                            overlap_h := ext_overlap_h
                            overlap_l := ext_overlap_l
                            end_idx := j
                        else
                            // 无法延伸,停止
                            break
                    
                    // 创建中枢
                    first_pen = array.get(pens, i + 1)
                    last_pen = array.get(pens, end_idx)
                    
                    box new_box = na
                    if show_pen_center
                        new_box := box.new(
                             left = first_pen.start_time, 
                             top = overlap_h, 
                             right = last_pen.end_time, 
                             bottom = overlap_l, 
                             bgcolor = PEN_CENTER_COLOR, 
                             border_color = PEN_COLOR, 
                             border_width = 1, 
                             xloc = xloc.bar_time)
                    
                    bool has_divergence = false
                    int exit_pen_idx = na
                    label sig_label = na
                    
                    // 检测离开笔背驰：取中枢后的第一笔，与中枢内最近的同向笔比较
                    exit_pen_idx := end_idx + 1 < pen_count ? end_idx + 1 : na
                    if not na(exit_pen_idx)
                        has_divergence := detect_pen_divergence(exit_pen_idx, i + 1)
                        if has_divergence and show_divergence_signals
                            exit_pen = array.get(pens, exit_pen_idx)
                            float sig_price = exit_pen.direction == 1 ? exit_pen.high : exit_pen.low
                            string sig_text = exit_pen.direction == 1 ? 'Sell(div)' : 'Buy(div)'
                            color sig_color = exit_pen.direction == 1 ? color.red : color.green
                            label.style sig_style = exit_pen.direction == 1 ? label.style_label_down : label.style_label_up
                            sig_label := label.new(
                                 x = exit_pen.end_time,
                                 y = sig_price,
                                 text = sig_text,
                                 color = sig_color,
                                 textcolor = color.white,
                                 style = sig_style,
                                 xloc = xloc.bar_time)
                            array.push(signal_labels, sig_label)
                    
                    array.push(pen_centers, PenCenter.new(
                         overlap_h, 
                         overlap_l, 
                         first_pen.start_time, 
                         last_pen.end_time, 
                         i + 1, 
                         end_idx, 
                         new_box,
                         has_divergence,
                         exit_pen_idx,
                         sig_label))
                    
                    // 更新最近中枢信息
                    last_center_high := overlap_h
                    last_center_low := overlap_l
                    last_center_exit_dir := not na(exit_pen_idx) ? array.get(pens, exit_pen_idx).direction : na
                    ready_buy3 := false
                    ready_sell3 := false
                    
                    // 若出现背驰，记录待确认1买/1卖
                    if has_divergence and not na(exit_pen_idx)
                        exit_pen = array.get(pens, exit_pen_idx)
                        pending_div_dir := exit_pen.direction
                        pending_div_price := exit_pen.direction == 1 ? exit_pen.high : exit_pen.low
                        pending_div_center_idx := array.size(pen_centers) - 1
                    
                    // 跳过已经处理的笔
                    i := end_idx
            
            i := i + 1
    
    true

// === 清理函数(简化) ===
cleanup_after_pen_change() =>
    // 当笔被删除或修改时,直接清除所有中枢
    // 下次check_and_add_center()会重新计算
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
            safe_delete_label(center.signal_label)
        array.clear(pen_centers)
    if array.size(signal_labels) > 0
        for i = 0 to array.size(signal_labels) - 1
            safe_delete_label(array.get(signal_labels, i))
        array.clear(signal_labels)

// === 主流程 ===
if na(current_kx)
    current_kx := Kx.new(high, low, time, -1, bar_index)
else
    bool has_include = (high >= current_kx.high and low <= current_kx.low) or 
                       (high <= current_kx.high and low >= current_kx.low)
    
    if has_include
        if array.size(kx_array) >= 1
            prev_kx = array.last(kx_array)
            bool uptrend = high > prev_kx.high or low > prev_kx.low
            
            if uptrend
                current_kx.high := math.max(high, current_kx.high)
                current_kx.low := math.max(low, current_kx.low)
            else
                current_kx.high := math.min(high, current_kx.high)
                current_kx.low := math.min(low, current_kx.low)
        else
            current_kx.high := math.max(high, current_kx.high)
            current_kx.low := math.min(low, current_kx.low)
        
        current_kx.time := time
        current_kx.bar_index := bar_index
    else
        current_kx.index := array.size(kx_array)
        array.push(kx_array, current_kx)
        
        if array.size(kx_array) >= 3
            k1 = array.get(kx_array, array.size(kx_array) - 3)
            k2 = array.get(kx_array, array.size(kx_array) - 2)
            k3 = array.get(kx_array, array.size(kx_array) - 1)
            
            is_top = k2.high > k1.high and k2.high > k3.high and 
                     k2.low > k1.low and k2.low > k3.low
            is_bot = k2.low < k1.low and k2.low < k3.low and 
                     k2.high < k1.high and k2.high < k3.high
            
            if is_top or is_bot
                new_price = is_top ? k2.high : k2.low
                new_time = k2.time
                new_type = is_top ? 1 : -1
                new_kx_index = k2.index
                
                if array.size(pen_fractals) == 0
                    label lbl = na
                    if show_fractal_labels
                        lbl := label.new(
                             x = new_time, 
                             y = new_price, 
                             text = is_top ? '顶' : '底', 
                             color = PEN_COLOR, 
                             textcolor = color.white, 
                             xloc = xloc.bar_time)
                    array.push(pen_fractals, Fx.new(
                         new_price, 
                         k2.high, 
                         k2.low, 
                         new_time, 
                         new_type, 
                         lbl, 
                         new_kx_index))
                else
                    lastfx = array.last(pen_fractals)
                    
                    if new_type != lastfx.type
                        bool is_valid = false
                        int kx_gap = new_kx_index - lastfx.kx_index
                        
                        if pen_algo == '新笔/严格笔'
                            if new_type == 1
                                is_valid := kx_gap >= 2 and k2.low > lastfx.fx_high
                            else
                                is_valid := kx_gap >= 2 and k2.high < lastfx.fx_low
                        else
                            is_valid := kx_gap >= 2
                        
                        if is_valid
                            label lbl2 = na
                            if show_fractal_labels
                                lbl2 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time)
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl2, 
                                 new_kx_index))
                            
                            // 交易点判定
                            process_trade_points(new_type, new_price, new_time)
                            
                            float pen_strength = get_pen_strength()
                            pline = line.new(
                                 x1 = lastfx.time, 
                                 y1 = lastfx.price, 
                                 x2 = new_time, 
                                 y2 = new_price, 
                                 color = PEN_COLOR, 
                                 width = PEN_WIDTH, 
                                 xloc = xloc.bar_time)
                            array.push(pen_lines, pline)
                            
                            pen_direction = new_type
                            array.push(pens, Pen.new(
                                 array.size(pen_fractals) - 2, 
                                 array.size(pen_fractals) - 1, 
                                 math.max(lastfx.price, new_price), 
                                 math.min(lastfx.price, new_price), 
                                 pen_direction, 
                                 lastfx.time, 
                                 new_time,
                                 pen_strength))
                            
                            // 每次添加笔后,重新计算所有中枢
                            bool result = check_and_add_center()
                    else
                        bool should_replace = false
                        if new_type == 1
                            should_replace := new_price > lastfx.price
                        else
                            should_replace := new_price < lastfx.price
                        
                        if should_replace
                            if not na(lastfx.label_id)
                                label.delete(lastfx.label_id)
                            if array.size(pen_lines) > 0
                                line.delete(array.pop(pen_lines))
                            if array.size(pens) > 0
                                array.pop(pens)
                                cleanup_after_pen_change()
                            array.pop(pen_fractals)
                            
                            label lbl3 = na
                            if show_fractal_labels
                                lbl3 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time)
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl3, 
                                 new_kx_index))
                            
                            // 交易点判定
                            process_trade_points(new_type, new_price, new_time)
                            
                            if array.size(pen_fractals) > 1
                                prevfx = array.get(pen_fractals, array.size(pen_fractals) - 2)
                                float pen_strength2 = get_pen_strength()
                                pline2 = line.new(
                                     x1 = prevfx.time, 
                                     y1 = prevfx.price, 
                                     x2 = new_time, 
                                     y2 = new_price, 
                                     color = PEN_COLOR, 
                                     width = PEN_WIDTH, 
                                     xloc = xloc.bar_time)
                                array.push(pen_lines, pline2)
                                
                                pen_direction = new_type
                                array.push(pens, Pen.new(
                                     array.size(pen_fractals) - 2, 
                                     array.size(pen_fractals) - 1, 
                                     math.max(prevfx.price, new_price), 
                                     math.min(prevfx.price, new_price), 
                                     pen_direction, 
                                     prevfx.time, 
                                     new_time,
                                     pen_strength2))
                                
                                // 每次修改笔后,重新计算所有中枢
                                bool result = check_and_add_center()
        
        current_kx := Kx.new(high, low, time, -1, bar_index)

plot(close, title = "helper", color = color.new(color.gray, 90), linewidth = 1)
