//@version=6
indicator('缠论自动画笔中枢 (Chanlun Pro)', '缠论笔中枢', overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// === 用户参数 ===
pen_algo = input.string('老笔', title = '画笔算法', options = ['老笔', '新笔/严格笔'])
min_pen_bars = input.int(5, title = '笔最小K线数', minval = 3, maxval = 10, tooltip = '一笔至少需要的合并K线数量')
gap_as_kl = input.bool(true, title = '缺口视为K线', tooltip = '如果两根K线之间有缺口，缺口可视为额外一根K线')
bi_end_is_peak = input.bool(true, title = '笔端点必须是极值', tooltip = '笔的结束点必须是笔内的最高/最低点')

// 线段设置
segment_enabled = input.bool(false, title = '启用线段', tooltip = '启用线段作为笔和中枢之间的中间层')

// 中枢设置
zs_algo = input.string('3笔中枢', title = '中枢算法', options = ['3笔中枢', '5笔中枢'], tooltip = '3笔中枢：连续3笔直接构成中枢；5笔中枢：需要进入笔+3笔+离开笔')
zs_one_bi = input.bool(false, title = '单笔中枢', tooltip = '允许单笔形成中枢')
zs_combine = input.bool(true, title = '中枢合并', tooltip = '相邻中枢有重叠时合并为更大中枢')
min_price_overlap_input = input.float(1.0, title = "中枢最小价格重叠", step = 0.5)
min_price_overlap = min_price_overlap_input * syminfo.mintick

// 买卖点设置
bsp_enabled = input.bool(true, title = '启用买卖点')
bsp_types = input.string('1,2,3a,3b', title = '买卖点类型', options = ['1,2,3a,3b', '1,2,3a,1p,2s,3b'], tooltip = '选择要检测的买卖点类型')
bsp_1_only_multi = input.bool(false, title = '1类买卖点仅多笔中枢', tooltip = '只在多笔中枢中寻找1类买卖点')
bsp_strict_3 = input.bool(false, title = '严格3类买卖点', tooltip = '使用严格的3类买卖点定义')

// 背驰检测
divergence_enabled = input.bool(true, title = '启用背驰检测')
divergence_algo = input.string('area', title = '背驰算法', options = ['area', 'peak', 'slope'], tooltip = '面积法、峰值法或斜率法')
divergence_rate = input.float(0.8, title = '背驰阈值', minval = 0.1, maxval = 1.0, step = 0.05, tooltip = '背驰判断阈值')
use_slope_divergence = input.bool(true, title = '使用笔力度（幅度/天数）判背驰')

// 显示设置
show_pen_center = input.bool(true, title = '显示笔中枢')
show_segments = input.bool(true, title = '显示线段')
show_centers = input.bool(true, title = '显示中枢')
show_fractal_labels = input.bool(false, title = '显示顶底分型标签')
show_divergence_signals = input.bool(true, title = '显示背驰信号')
show_trade_signals = input.bool(true, title = '显示买卖点')
show_labels = input.bool(true, title = '显示价格标签')
show_info_table = input.bool(true, title = '显示信息表')
max_display_items = input.int(50, title = '最大显示数量', maxval = 50)

// MACD参数
macd_fast = input.int(12, title = 'MACD快线周期', minval = 1)
macd_slow = input.int(26, title = 'MACD慢线周期', minval = 1)
macd_signal = input.int(9, title = 'MACD信号线周期', minval = 1)

// === 颜色 ===
PEN_COLOR = color.new(color.blue, 0)
PEN_UP_COLOR = color.new(color.red, 0)
PEN_DOWN_COLOR = color.new(color.green, 0)
PEN_CENTER_COLOR = color.new(color.blue, 80)
PEN_WIDTH = 2

// === MACD计算 ===
[macd_line, signal_line, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)

// === 类型定义 ===
type Kx
    float high
    float low
    int time
    int index
    int bar_idx  // 原始bar_index，用于计算MACD面积

type Fx
    float price
    float fx_high
    float fx_low
    int time
    int type      // 1=顶分型, -1=底分型
    label label_id
    int kx_index
    int bar_idx   // 原始bar_index
    bool confirmed // 分型是否已确认

type Pen
    int start_fx_idx
    int end_fx_idx
    float high
    float low
    int direction  // 1=向上笔, -1=向下笔
    int start_time
    int end_time
    int start_bar_idx
    int end_bar_idx
    float macd_area  // MACD面积（力度）
    bool confirmed   // 笔是否已确认
    int kx_count     // 合并K线数量
    float amplitude  // 笔幅（价格变化）
    float slope      // 笔力度（幅度/天数）

type Segment
    int start_pen_idx
    int end_pen_idx
    float high
    float low
    int direction  // 1=向上线段, -1=向下线段
    int start_time
    int end_time
    int start_bar_idx
    int end_bar_idx
    line line_id
    bool broken    // 是否被突破
    bool confirmed // 是否已确认

type PenCenter
    float high      // ZG = min(高点1, 高点2)
    float low       // ZD = max(低点1, 低点2)
    float gg        // 中枢最高点
    float dd        // 中枢最低点
    float mid       // 中枢中轴
    int start_time
    int end_time
    int start_pen_idx
    int end_pen_idx
    box box_id
    bool closed     // 中枢是否已封闭
    int direction   // 1=上涨中枢, -1=下跌中枢
    bool extended   // 是否扩展为更大级别中枢
    int level       // 中枢级别
    bool is_breakout // 是否已突破
    float breakout_price // 突破价格

type TradeSignal
    int type        // 1=1买, 1p=1买增强, 2=2买, 2s=2买增强, 3a=3买a类, 3b=3买b类, negative for sell
    int level       // 买卖点级别
    int bar_idx
    int time
    float price
    int ref_pen_idx
    int ref_center_idx
    string reason   // 产生原因
    label label_id

// === 全局变量 ===
var kx_array = array.new<Kx>()
var pen_fractals = array.new<Fx>()
var pen_lines = array.new<line>()
var pens = array.new<Pen>()
var segments = array.new<Segment>()
var pen_centers = array.new<PenCenter>()
var trade_signals = array.new<TradeSignal>()
var Kx current_kx = na

// 存储MACD历史值用于面积计算
var macd_hist_array = array.new<float>()

// 买卖点状态追踪
var int last_buy1_pen_idx = na      // 最近1买对应的笔索引
var float last_buy1_price = na      // 1买价格
var int last_sell1_pen_idx = na     // 最近1卖对应的笔索引
var float last_sell1_price = na     // 1卖价格
var int last_closed_center_idx = na // 最近封闭的中枢索引

// === 辅助函数 ===
safe_delete_box(b) =>
    if not na(b)
        box.delete(b)

safe_delete_label(l) =>
    if not na(l)
        label.delete(l)

safe_delete_line(l) =>
    if not na(l)
        line.delete(l)

// === 绘图对象管理 ===
// 清理旧的绘图对象以保持在限制范围内
cleanup_drawing_objects() =>
    // 清理多余的笔线
    while array.size(pen_lines) > max_display_items
        line.delete(array.shift(pen_lines))

    // 清理多余的线段
    while array.size(segments) > max_display_items / 2
        seg = array.shift(segments)
        if not na(seg.line_id)
            line.delete(seg.line_id)

    // 清理过多的中枢框
    while array.size(pen_centers) > max_display_items / 3
        center = array.shift(pen_centers)
        safe_delete_box(center.box_id)

    // 清理过多的买卖点标签
    int max_signals = 20
    while array.size(trade_signals) > max_signals
        sig = array.shift(trade_signals)
        safe_delete_label(sig.label_id)

// 按优先级显示
draw_by_priority() =>
    if barstate.islast
        // 1. 确保显示最新的买卖点（最高优先级）
        if array.size(trade_signals) > 0
            latest_signals = array.slice(trade_signals, math.max(0, array.size(trade_signals) - 5), array.size(trade_signals))
            for i = 0 to array.size(latest_signals) - 1
                sig = array.get(latest_signals, i)
                if na(sig.label_id) and show_trade_signals
                    sig.label_id := add_trade_signal_label(sig.time, sig.price,
                        sig.type == 101 ? "1B+" : sig.type == -101 ? "1S+" :
                        sig.type == 202 ? "2B+" : sig.type == -202 ? "2S+" :
                        sig.type == 1 ? "1B" : sig.type == -1 ? "1S" :
                        sig.type == 2 ? "2B" : sig.type == -2 ? "2S" :
                        sig.type == 3 ? "3B" : sig.type == -3 ? "3S" : "",
                        sig.type > 0 ? 1 : -1)

        // 2. 确保显示当前中枢
        if array.size(pen_centers) > 0 and show_pen_center
            latest_center = array.get(pen_centers, array.size(pen_centers) - 1)
            if na(latest_center.box_id)
                latest_center.box_id := box.new(
                    left = latest_center.start_time,
                    top = latest_center.high,
                    right = latest_center.end_time,
                    bottom = latest_center.low,
                    bgcolor = PEN_CENTER_COLOR,
                    border_color = PEN_COLOR,
                    border_width = 1,
                    xloc = xloc.bar_time)

        // 3. 确保显示最近的笔
        if array.size(pen_lines) > 0 and show_pen_center
            int recent_count = math.min(max_display_items, array.size(pen_lines))
            recent_lines = array.slice(pen_lines, array.size(pen_lines) - recent_count, array.size(pen_lines))
            // 确保最近的笔线存在（已在创建时处理）

        // 4. 清理多余对象
        cleanup_drawing_objects()

// 检查两根合并K线之间是否有缺口
has_gap_between(kx1_idx, kx2_idx) =>
    bool has_gap = false
    if kx1_idx >= 0 and kx2_idx > kx1_idx and kx2_idx < array.size(kx_array)
        kx1 = array.get(kx_array, kx1_idx)
        kx2 = array.get(kx_array, kx2_idx)
        // 缺口：两根K线高低无重叠
        has_gap := kx1.high < kx2.low or kx1.low > kx2.high
    has_gap

// 计算两个分型之间的缺口数量（用于gap_as_kl）
count_gaps_between(start_kx_idx, end_kx_idx) =>
    int gap_count = 0
    if gap_as_kl and start_kx_idx >= 0 and end_kx_idx > start_kx_idx
        for i = start_kx_idx to end_kx_idx - 1
            if has_gap_between(i, i + 1)
                gap_count := gap_count + 1
    gap_count

// 检查笔端点是否是极值（参考Python的end_is_peak）
check_end_is_peak(start_kx_idx, end_kx_idx, is_up) =>
    bool is_peak = true
    if bi_end_is_peak and start_kx_idx >= 0 and end_kx_idx > start_kx_idx
        end_kx = array.get(kx_array, end_kx_idx)
        float cmp_value = is_up ? end_kx.high : end_kx.low
        // 检查笔内所有K线，确保端点是极值
        for i = start_kx_idx + 1 to end_kx_idx - 1
            kx = array.get(kx_array, i)
            if is_up and kx.high > cmp_value
                is_peak := false
                break
            if not is_up and kx.low < cmp_value
                is_peak := false
                break
    is_peak

// 计算指定bar范围内的MACD面积
calc_macd_area(start_bar, end_bar, dir) =>
    float area = 0.0
    int arr_size = array.size(macd_hist_array)
    if arr_size > 0
        for i = math.max(0, start_bar) to math.min(arr_size - 1, end_bar)
            float hist_val = array.get(macd_hist_array, i)
            // 向上笔统计正值面积，向下笔统计负值面积的绝对值
            if dir == 1  // 向上笔
                if hist_val > 0
                    area += hist_val
            else  // 向下笔
                if hist_val < 0
                    area += math.abs(hist_val)
    area

// 添加交易信号标签
add_trade_signal_label(t, price, txt, sig_type) =>
    label lb = na
    if show_trade_signals
        lb := label.new(
             x = t,
             y = price,
             text = txt,
             color = sig_type > 0 ? color.green : color.red,
             textcolor = color.white,
             style = sig_type > 0 ? label.style_label_up : label.style_label_down,
             size = size.small,
             xloc = xloc.bar_time)
    lb

// === 背驰检测 ===
// 检测笔的背驰：比较两段同向笔的MACD面积和笔力度
detect_bi_divergence(current_pen_idx) =>
    bool has_divergence = false
    float area_current = 0.0
    float area_prev = 0.0
    bool macd_div = false
    bool slope_div = false
    
    if current_pen_idx >= 2 and current_pen_idx < array.size(pens)
        current_pen = array.get(pens, current_pen_idx)
        
        // 寻找前一个同向笔
        int prev_same_dir_idx = na
        int search_idx = current_pen_idx - 2
        while search_idx >= 0
            prev_pen = array.get(pens, search_idx)
            if prev_pen.direction == current_pen.direction
                prev_same_dir_idx := search_idx
                break
            search_idx := search_idx - 2
        
        if not na(prev_same_dir_idx)
            prev_pen = array.get(pens, prev_same_dir_idx)
            
            // 计算两笔的MACD面积
            area_current := current_pen.macd_area
            area_prev := prev_pen.macd_area
            
            // 判断是否创新高/新低
            bool price_new_extreme = false
            if current_pen.direction == 1  // 向上笔
                price_new_extreme := current_pen.high > prev_pen.high
            else  // 向下笔
                price_new_extreme := current_pen.low < prev_pen.low
            
            // MACD背驰：价格创新极值但MACD力度减弱
            if price_new_extreme and area_prev > 0
                if area_current < area_prev * divergence_ratio
                    macd_div := true
            
            // 笔力度背驰（参考Rust实现）：笔天数>=前笔 且 (笔幅<前笔 或 笔力度<前笔)
            if use_slope_divergence and price_new_extreme
                bool bars_longer = current_pen.kx_count >= prev_pen.kx_count
                bool amp_weaker = current_pen.amplitude < prev_pen.amplitude
                bool slope_weaker = current_pen.slope < prev_pen.slope * divergence_ratio
                if bars_longer and (amp_weaker or slope_weaker)
                    slope_div := true
            
            // MACD背驰或笔力度背驰任一成立
            has_divergence := macd_div or slope_div
    
    [has_divergence, area_current, area_prev]

// === 计算多笔的真实重叠区间 ===
get_pens_overlap(pen_indices) =>
    if array.size(pen_indices) < 3
        [na, na]
    else
        first_idx = array.get(pen_indices, 0)
        first_pen = array.get(pens, first_idx)
        float overlap_high = first_pen.high
        float overlap_low = first_pen.low
        
        bool has_valid_overlap = true
        for i = 1 to array.size(pen_indices) - 1
            pen_idx = array.get(pen_indices, i)
            pen = array.get(pens, pen_idx)
            
            float new_low = math.max(overlap_low, pen.low)
            float new_high = math.min(overlap_high, pen.high)
            
            if new_high <= new_low or (new_high - new_low) < min_price_overlap
                has_valid_overlap := false
                break
            
            overlap_high := new_high
            overlap_low := new_low
        
        if has_valid_overlap and overlap_high > overlap_low
            [overlap_high, overlap_low]
        else
            [na, na]

// === 线段构建 ===
// 使用缠论标准线段算法：线段由笔构成，当反向笔不创新高/新低时线段结束
build_segments() =>
    if array.size(pens) >= 3
        // 清理旧线段
        for i = 0 to array.size(segments) - 1
            seg = array.get(segments, i)
            if not na(seg.line_id)
                line.delete(seg.line_id)
        array.clear(segments)

        int i = 0
        while i < array.size(pens) - 2
            pen1 = array.get(pens, i)
            pen2 = array.get(pens, i + 1)
            pen3 = array.get(pens, i + 2)

            // 检查是否形成线段特征序列
            if pen1.direction == 1 and pen2.direction == -1 and pen3.direction == 1
                // 上涨线段：上-下-上结构
                if pen3.high <= pen1.high
                    // 第三笔不创新高，可能形成线段
                    seg_high = math.max(pen1.high, pen2.high)
                    seg_low = math.min(pen1.low, pen2.low)

                    line_id = na
                    if show_segments
                        line_id := line.new(
                            x1 = pen1.start_time,
                            y1 = pen1.low,
                            x2 = pen2.end_time,
                            y2 = pen2.high,
                            color = color.new(color.purple, 0),
                            width = 2,
                            xloc = xloc.bar_time)

                    array.push(segments, Segment.new(
                        i, i + 1, seg_high, seg_low, 1,
                        pen1.start_time, pen2.end_time,
                        pen1.start_bar_idx, pen2.end_bar_idx,
                        line_id, false, false))
                    i := i + 2
                else
                    i := i + 1
            else if pen1.direction == -1 and pen2.direction == 1 and pen3.direction == -1
                // 下跌线段：下-上-下结构
                if pen3.low >= pen1.low
                    // 第三笔不创新低，可能形成线段
                    seg_high = math.max(pen1.high, pen2.high)
                    seg_low = math.min(pen1.low, pen2.low)

                    line_id = na
                    if show_segments
                        line_id := line.new(
                            x1 = pen1.start_time,
                            y1 = pen1.high,
                            x2 = pen2.end_time,
                            y2 = pen2.low,
                            color = color.new(color.orange, 0),
                            width = 2,
                            xloc = xloc.bar_time)

                    array.push(segments, Segment.new(
                        i, i + 1, seg_high, seg_low, -1,
                        pen1.start_time, pen2.end_time,
                        pen1.start_bar_idx, pen2.end_bar_idx,
                        line_id, false, false))
                    i := i + 2
                else
                    i := i + 1
            else
                i := i + 1

// === 清理所有中枢和信号 ===
cleanup_all_centers_and_signals() =>
    // 清理中枢
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)
    
    // 清理交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    true

// === 第一类买点检测 ===
// 严格缠论定义：
// 1. "跌-涨-跌"结构（两段下跌笔中间有一段上涨笔连接）
// 2. 第二段下跌笔的低点 < 第一段下跌笔的低点（创新低）
// 3. 第二段下跌相比第一段出现背驰
// 4. 底分型确认
// 返回 [triggered, pen_idx, price, type]
check_buy1(pen_idx, ref_buy1_pen_idx, ref_buy1_price) =>
    bool triggered = false
    int result_pen_idx = ref_buy1_pen_idx
    float result_price = ref_buy1_price
    int signal_type = 1  // 默认1买

    // 需要至少3笔形成"跌-涨-跌"结构
    if pen_idx >= 2 and pen_idx < array.size(pens)
        pen3 = array.get(pens, pen_idx)      // 第二段下跌笔（当前笔）
        pen2 = array.get(pens, pen_idx - 1)  // 中间上涨笔
        pen1 = array.get(pens, pen_idx - 2)  // 第一段下跌笔

        // 验证"跌-涨-跌"结构
        bool is_valid_structure = pen1.direction == -1 and pen2.direction == 1 and pen3.direction == -1

        // 必须是已确认的向下笔
        if is_valid_structure and pen3.confirmed
            // 条件2：创新低
            bool creates_new_low = pen3.low < pen1.low

            if creates_new_low
                // 条件3：背驰判断
                // 价格背驰：第二段跌幅 ≤ 第一段跌幅
                float drop1 = pen1.high - pen1.low  // 第一段下跌幅度
                float drop2 = pen3.high - pen3.low  // 第二段下跌幅度
                bool price_divergence = drop2 <= drop1

                // MACD背驰：第二段MACD面积 < 第一段
                bool macd_divergence = pen3.macd_area < pen1.macd_area * divergence_ratio

                // 笔力度背驰（可选）
                bool slope_divergence = false
                if use_slope_divergence
                    slope_divergence := pen3.slope <= pen1.slope * divergence_ratio

                // 判断背驰强度以区分1买和1买增强
                float macd_ratio = pen1.macd_area > 0 ? pen3.macd_area / pen1.macd_area : 1.0

                // 满足任一背驰条件
                if price_divergence or macd_divergence or slope_divergence
                    triggered := true
                    result_pen_idx := pen_idx
                    result_price := pen3.low

                    // 判断是否为1买增强（更强烈的背驰）
                    if macd_divergence and macd_ratio < divergence_ratio * 0.7
                        signal_type := 101  // 1买增强编码
    [triggered, result_pen_idx, result_price, signal_type]

// === 第一类卖点检测 ===
// 严格缠论定义：
// 1. "涨-跌-涨"结构（两段上涨笔中间有一段下跌笔连接）
// 2. 第二段上涨笔的高点 > 第一段上涨笔的高点（创新高）
// 3. 第二段上涨相比第一段出现背驰
// 4. 顶分型确认
check_sell1(pen_idx, ref_sell1_pen_idx, ref_sell1_price) =>
    bool triggered = false
    int result_pen_idx = ref_sell1_pen_idx
    float result_price = ref_sell1_price
    int signal_type = -1  // 默认1卖

    // 需要至少3笔形成"涨-跌-涨"结构
    if pen_idx >= 2 and pen_idx < array.size(pens)
        pen3 = array.get(pens, pen_idx)      // 第二段上涨笔（当前笔）
        pen2 = array.get(pens, pen_idx - 1)  // 中间下跌笔
        pen1 = array.get(pens, pen_idx - 2)  // 第一段上涨笔

        // 验证"涨-跌-涨"结构
        bool is_valid_structure = pen1.direction == 1 and pen2.direction == -1 and pen3.direction == 1

        // 必须是已确认的向上笔
        if is_valid_structure and pen3.confirmed
            // 条件2：创新高
            bool creates_new_high = pen3.high > pen1.high

            if creates_new_high
                // 条件3：背驰判断
                // 价格背驰：第二段涨幅 ≤ 第一段涨幅
                float rise1 = pen1.high - pen1.low  // 第一段上涨幅度
                float rise2 = pen3.high - pen3.low  // 第二段上涨幅度
                bool price_divergence = rise2 <= rise1

                // MACD背驰：第二段MACD面积 < 第一段
                bool macd_divergence = pen3.macd_area < pen1.macd_area * divergence_ratio

                // 笔力度背驰（可选）
                bool slope_divergence = false
                if use_slope_divergence
                    slope_divergence := pen3.slope <= pen1.slope * divergence_ratio

                // 判断背驰强度以区分1卖和1卖增强
                float macd_ratio = pen1.macd_area > 0 ? pen3.macd_area / pen1.macd_area : 1.0

                // 满足任一背驰条件
                if price_divergence or macd_divergence or slope_divergence
                    triggered := true
                    result_pen_idx := pen_idx
                    result_price := pen3.high

                    // 判断是否为1卖增强（更强烈的背驰）
                    if macd_divergence and macd_ratio < divergence_ratio * 0.7
                        signal_type := -101  // 1卖增强编码
    [triggered, result_pen_idx, result_price, signal_type]

// === 第二类买点检测 ===
// 严格缠论定义：
// 1. 已确认第一类买点（B1）
// 2. 价格从B1反弹形成上涨笔
// 3. 随后回调形成下跌笔
// 4. 该下跌笔的低点 > B1的价格（不破前低）
// 5. 回调结束时出现底分型 → 第二类买点
check_buy2(pen_idx, ref_buy1_pen_idx, ref_buy1_price) =>
    bool triggered = false
    int signal_type = 2  // 默认2买

    // 需要B1存在，且当前笔在B1之后至少2笔（反弹笔+回调笔）
    if not na(ref_buy1_pen_idx) and pen_idx > ref_buy1_pen_idx + 1 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 条件3/5：必须是向下回调笔且已确认（底分型确认）
        if pen.direction == -1 and pen.confirmed
            // 条件4：回调低点不能破B1低点
            if pen.low > ref_buy1_price
                // 条件2：确保之前有向上反弹笔
                prev_pen = array.get(pens, pen_idx - 1)
                if prev_pen.direction == 1  // 前一笔是向上反弹
                    triggered := true

                    // 检查是否为2买增强（更强的支撑）
                    if pen.low > ref_buy1_price * 1.01  // 回调低点明显高于B1
                        signal_type := 202  // 2买增强编码

    [triggered, signal_type]

// === 第二类卖点检测 ===
// 严格缠论定义：
// 1. 已确认第一类卖点（S1）
// 2. 价格从S1下跌形成下跌笔
// 3. 随后反弹形成上涨笔
// 4. 该上涨笔的高点 < S1的价格（不破前高）
// 5. 反弹结束时出现顶分型 → 第二类卖点
check_sell2(pen_idx, ref_sell1_pen_idx, ref_sell1_price) =>
    bool triggered = false
    int signal_type = -2  // 默认2卖

    // 需要S1存在，且当前笔在S1之后至少2笔（下跌笔+反弹笔）
    if not na(ref_sell1_pen_idx) and pen_idx > ref_sell1_pen_idx + 1 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)

        // 条件3/5：必须是向上反弹笔且已确认（顶分型确认）
        if pen.direction == 1 and pen.confirmed
            // 条件4：反弹高点不能破S1高点
            if pen.high < ref_sell1_price
                // 条件2：确保之前有向下回调笔
                prev_pen = array.get(pens, pen_idx - 1)
                if prev_pen.direction == -1  // 前一笔是向下回调
                    triggered := true

                    // 检查是否为2卖增强（更强的阻力）
                    if pen.high < ref_sell1_price * 0.99  // 反弹高点明显低于S1
                        signal_type := -202  // 2卖增强编码

    [triggered, signal_type]

// === 第三类买点检测 ===
// 严格缠论定义：
// 1. 存在上涨中枢（"上-下-上"结构, direction = 1）
// 2. 中枢完成后，价格向上突破ZG，形成离开中枢的上涨笔
// 3. 随后回调形成下跌笔
// 4. 回调低点 > ZG（即未进入中枢区间）
// 5. 回调结束出现底分型 → 第三类买点
check_buy3(pen_idx) =>
    bool triggered = false
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向下回调笔且已确认
        if pen.direction == -1 and pen.confirmed
            // 检查所有封闭中枢
            int center_idx = array.size(pen_centers) - 1
            while center_idx >= 0 and not triggered
                center = array.get(pen_centers, center_idx)
                
                // 条件1：必须是上涨中枢（上-下-上结构）
                if center.direction == 1 and center.closed and pen_idx > center.end_pen_idx + 1
                    // 条件2：检查是否有向上突破笔（离开中枢的笔）
                    int exit_pen_idx = center.end_pen_idx + 1
                    if exit_pen_idx < array.size(pens)
                        exit_pen = array.get(pens, exit_pen_idx)
                        
                        // 向上突破：离开笔是向上且高点超过ZG
                        if exit_pen.direction == 1 and exit_pen.high > center.high
                            // 条件3/4：当前回调笔在突破后，且低点不入中枢（低点 > ZG）
                            if pen_idx > exit_pen_idx and pen.low > center.high
                                triggered := true
                center_idx := center_idx - 1
    triggered

// === 第三类卖点检测 ===
// 严格缠论定义：
// 1. 存在下跌中枢（"下-上-下"结构, direction = -1）
// 2. 中枢完成后，价格向下跌破ZD
// 3. 随后反弹形成上涨笔
// 4. 反弹高点 < ZD（即未进入中枢区间）
// 5. 顶分型确认 → 第三类卖点
check_sell3(pen_idx) =>
    bool triggered = false
    if array.size(pen_centers) > 0 and pen_idx < array.size(pens)
        pen = array.get(pens, pen_idx)
        
        // 必须是向上反弹笔且已确认
        if pen.direction == 1 and pen.confirmed
            // 检查所有封闭中枢
            int center_idx2 = array.size(pen_centers) - 1
            while center_idx2 >= 0 and not triggered
                center = array.get(pen_centers, center_idx2)
                
                // 条件1：必须是下跌中枢（下-上-下结构）
                if center.direction == -1 and center.closed and pen_idx > center.end_pen_idx + 1
                    // 条件2：检查是否有向下跌破笔（离开中枢的笔）
                    int exit_pen_idx = center.end_pen_idx + 1
                    if exit_pen_idx < array.size(pens)
                        exit_pen = array.get(pens, exit_pen_idx)
                        
                        // 向下跌破：离开笔是向下且低点低于ZD
                        if exit_pen.direction == -1 and exit_pen.low < center.low
                            // 条件3/4：当前反弹笔在跌破后，且高点不入中枢（高点 < ZD）
                            if pen_idx > exit_pen_idx and pen.high < center.low
                                triggered := true
                center_idx2 := center_idx2 - 1
    triggered

// === 中枢检测与构建 ===
// 支持两种算法：
// 1. 3笔中枢：连续3笔直接构成中枢（上-下-上 或 下-上-下）
// 2. 5笔中枢：需要进入笔 + 3笔中枢 + 离开笔
check_and_build_centers() =>
    pen_count = array.size(pens)
    
    // 清理所有现有中枢
    if array.size(pen_centers) > 0
        for i = 0 to array.size(pen_centers) - 1
            center = array.get(pen_centers, i)
            safe_delete_box(center.box_id)
        array.clear(pen_centers)
    
    // 清理旧的交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    
    // 根据算法选择不同的中枢构建逻辑
    if zs_algo == '3笔中枢'
        // ============ 3笔中枢算法 ============
        // 连续3笔直接构成中枢
        if pen_count >= 3
            int i = 0
            while i <= pen_count - 3
                pen1 = array.get(pens, i)
                pen2 = array.get(pens, i + 1)
                pen3 = array.get(pens, i + 2)
                
                // 验证中枢结构：上-下-上 或 下-上-下
                bool valid_structure = false
                int center_dir = 0
                
                if pen1.direction == 1 and pen2.direction == -1 and pen3.direction == 1
                    valid_structure := true
                    center_dir := 1  // 上涨中枢
                else if pen1.direction == -1 and pen2.direction == 1 and pen3.direction == -1
                    valid_structure := true
                    center_dir := -1  // 下跌中枢
                
                if valid_structure
                    // ZG = 三笔高点的最小值, ZD = 三笔低点的最大值
                    float zg = math.min(pen1.high, math.min(pen2.high, pen3.high))
                    float zd = math.max(pen1.low, math.max(pen2.low, pen3.low))
                    
                    if zg >= zd + min_price_overlap
                        bool is_covered = false
                        if array.size(pen_centers) > 0
                            for k = 0 to array.size(pen_centers) - 1
                                existing = array.get(pen_centers, k)
                                if i >= existing.start_pen_idx and i <= existing.end_pen_idx
                                    is_covered := true
                                    break
                        
                        if not is_covered
                            float center_gg = math.max(pen1.high, math.max(pen2.high, pen3.high))
                            float center_dd = math.min(pen1.low, math.min(pen2.low, pen3.low))
                            int end_idx = i + 2
                            
                            // 尝试延伸中枢（只有当有更多笔时才尝试）
                            if i + 3 < pen_count
                                for j = i + 3 to pen_count - 1
                                    ext_pen = array.get(pens, j)
                                    bool enters_zs = ext_pen.high >= zd and ext_pen.low <= zg
                                    if enters_zs
                                        float new_zg = math.min(zg, ext_pen.high)
                                        float new_zd = math.max(zd, ext_pen.low)
                                        if new_zg >= new_zd + min_price_overlap
                                            zg := new_zg
                                            zd := new_zd
                                            end_idx := j
                                            center_gg := math.max(center_gg, ext_pen.high)
                                            center_dd := math.min(center_dd, ext_pen.low)
                                        else
                                            break
                                    else
                                        break

                            float center_mid = (zg + zd) / 2
                            bool is_closed = end_idx + 1 < pen_count
                            last_pen = array.get(pens, end_idx)

                            box new_box = na
                            if show_pen_center
                                new_box := box.new(left = pen1.start_time, top = zg, right = last_pen.end_time, bottom = zd,
                                     bgcolor = PEN_CENTER_COLOR, border_color = PEN_COLOR, border_width = 1, xloc = xloc.bar_time)

                            array.push(pen_centers, PenCenter.new(zg, zd, center_gg, center_dd, center_mid, pen1.start_time, last_pen.end_time,
                                 i, end_idx, new_box, is_closed, center_dir, false, 1, false, 0.0))
                            i := end_idx
                
                i := i + 1
    else
        // ============ 5笔中枢算法 ============
        // 需要5笔：进入笔 + 3笔中枢 + 离开笔
        if pen_count >= 5
            int i = 0
            while i <= pen_count - 5
                // 中枢内部笔: i+1, i+2, i+3
                pen_in = array.get(pens, i)      // 进入笔
                pen1 = array.get(pens, i + 1)
                pen2 = array.get(pens, i + 2)
                pen3 = array.get(pens, i + 3)
                
                // 计算3笔的重叠区间
                float zg = math.min(pen1.high, math.min(pen2.high, pen3.high))
                float zd = math.max(pen1.low, math.max(pen2.low, pen3.low))
                
                if zg >= zd + min_price_overlap
                    bool is_covered = false
                    if array.size(pen_centers) > 0
                        for k = 0 to array.size(pen_centers) - 1
                            existing = array.get(pen_centers, k)
                            if i + 1 >= existing.start_pen_idx and i + 1 <= existing.end_pen_idx
                                is_covered := true
                                break
                    
                    if not is_covered
                        float center_gg = math.max(pen1.high, math.max(pen2.high, pen3.high))
                        float center_dd = math.min(pen1.low, math.min(pen2.low, pen3.low))
                        int end_idx = i + 3
                        
                        // 尝试延伸中枢（只有当有更多笔时才尝试）
                        if i + 4 <= pen_count - 2
                            for j = i + 4 to pen_count - 2
                                ext_pen = array.get(pens, j)
                                float new_zg = math.min(zg, ext_pen.high)
                                float new_zd = math.max(zd, ext_pen.low)
                                if new_zg >= new_zd + min_price_overlap
                                    zg := new_zg
                                    zd := new_zd
                                    end_idx := j
                                    center_gg := math.max(center_gg, ext_pen.high)
                                    center_dd := math.min(center_dd, ext_pen.low)
                                else
                                    break
                        
                        // 判断中枢方向（基于进入笔）
                        int center_dir = pen_in.direction == -1 ? -1 : 1
                        bool is_closed = end_idx + 1 < pen_count

                        first_pen = array.get(pens, i + 1)
                        last_pen = array.get(pens, end_idx)
                        float center_mid = (zg + zd) / 2

                        box new_box = na
                        if show_pen_center
                            new_box := box.new(left = first_pen.start_time, top = zg, right = last_pen.end_time, bottom = zd,
                                 bgcolor = PEN_CENTER_COLOR, border_color = PEN_COLOR, border_width = 1, xloc = xloc.bar_time)

                        array.push(pen_centers, PenCenter.new(zg, zd, center_gg, center_dd, center_mid, first_pen.start_time, last_pen.end_time,
                             i + 1, end_idx, new_box, is_closed, center_dir, false, 1, false, 0.0))
                        i := end_idx
                
                i := i + 1
    
    // 中枢合并（参考Python实现的combine逻辑）
    // 两个中枢如果ZG-ZD区间有重叠，可以合并为更大级别中枢
    if zs_combine and array.size(pen_centers) >= 2
        bool merged = true
        while merged and array.size(pen_centers) >= 2
            merged := false
            int idx = array.size(pen_centers) - 2
            if idx >= 0
                curr = array.get(pen_centers, idx)
                next = array.get(pen_centers, idx + 1)
                // 检查ZG-ZD区间是否有重叠
                bool has_overlap = math.max(curr.low, next.low) < math.min(curr.high, next.high)
                if has_overlap
                    // 合并中枢：扩展curr，删除next
                    curr.low := math.min(curr.low, next.low)
                    curr.high := math.max(curr.high, next.high)
                    curr.gg := math.max(curr.gg, next.gg)
                    curr.dd := math.min(curr.dd, next.dd)
                    curr.end_time := next.end_time
                    curr.end_pen_idx := next.end_pen_idx
                    curr.closed := next.closed
                    curr.extended := true
                    // 更新box
                    if show_pen_center and not na(curr.box_id)
                        box.set_top(curr.box_id, curr.high)
                        box.set_bottom(curr.box_id, curr.low)
                        box.set_right(curr.box_id, curr.end_time)
                        box.set_border_color(curr.box_id, color.orange)  // 合并后的中枢用橙色边框
                    // 删除next
                    safe_delete_box(next.box_id)
                    array.pop(pen_centers)
                    merged := true
    
    // 检测中枢扩展（参考Rust实现）
    if array.size(pen_centers) >= 2
        int idx = 0
        while idx < array.size(pen_centers) - 1
            curr = array.get(pen_centers, idx)
            next = array.get(pen_centers, idx + 1)
            // 中枢扩展：后中枢ZG < 前中枢ZD 且 后中枢GG >= 前中枢DD
            //          或 后中枢ZD > 前中枢ZG 且 后中枢DD <= 前中枢GG
            bool expand_down = next.high < curr.low and next.gg >= curr.dd
            bool expand_up = next.low > curr.high and next.dd <= curr.gg
            if expand_down or expand_up
                curr.extended := true
                next.extended := true
            idx := idx + 1
    
    // 处理买卖点信号 - 在主流程中处理
    true

// === 清理函数（笔变化时调用）===
cleanup_after_pen_change() =>
    cleanup_all_centers_and_signals()

// === 性能优化 ===
// 使用缓存变量避免重复计算
var int last_calculated_bar = 0
var bool needs_recalculate = true
var int last_pen_count = 0
var int last_center_count = 0

// 检查是否需要重新计算
if bar_index != last_calculated_bar
    needs_recalculate := true
    last_calculated_bar := bar_index
else
    needs_recalculate := false

// 限制历史数据大小
MAX_HISTORY = 1000
if array.size(pens) > MAX_HISTORY
    pens := array.slice(pens, array.size(pens) - MAX_HISTORY, array.size(pens))
if array.size(pen_centers) > MAX_HISTORY / 10
    pen_centers := array.slice(pen_centers, array.size(pen_centers) - MAX_HISTORY / 10, array.size(pen_centers))

// === 主流程 ===
// 存储当前bar的MACD值
array.push(macd_hist_array, macd_hist)

// 限制MACD历史数组大小
if array.size(macd_hist_array) > MAX_HISTORY * 10
    macd_hist_array := array.slice(macd_hist_array, array.size(macd_hist_array) - MAX_HISTORY * 10, array.size(macd_hist_array))

if na(current_kx)
    current_kx := Kx.new(high, low, time, -1, bar_index)
else
    bool has_include = (high >= current_kx.high and low <= current_kx.low) or 
                       (high <= current_kx.high and low >= current_kx.low)
    
    if has_include
        // 包含关系处理
        if array.size(kx_array) >= 1
            prev_kx = array.last(kx_array)
            bool uptrend = high > prev_kx.high or low > prev_kx.low
            
            if uptrend
                current_kx.high := math.max(high, current_kx.high)
                current_kx.low := math.max(low, current_kx.low)
            else
                current_kx.high := math.min(high, current_kx.high)
                current_kx.low := math.min(low, current_kx.low)
        else
            current_kx.high := math.max(high, current_kx.high)
            current_kx.low := math.min(low, current_kx.low)
        
        current_kx.time := time
        current_kx.bar_idx := bar_index
    else
        // 无包含，完成当前K线
        current_kx.index := array.size(kx_array)
        array.push(kx_array, current_kx)
        
        // 分型检测（需要至少3根合并K线）
        if array.size(kx_array) >= 3
            k1 = array.get(kx_array, array.size(kx_array) - 3)
            k2 = array.get(kx_array, array.size(kx_array) - 2)
            k3 = array.get(kx_array, array.size(kx_array) - 1)
            
            is_top = k2.high > k1.high and k2.high > k3.high and 
                     k2.low > k1.low and k2.low > k3.low
            is_bot = k2.low < k1.low and k2.low < k3.low and 
                     k2.high < k1.high and k2.high < k3.high
            
            if is_top or is_bot
                new_price = is_top ? k2.high : k2.low
                new_time = k2.time
                new_type = is_top ? 1 : -1
                new_kx_index = k2.index
                new_bar_idx = k2.bar_idx
                
                // 确认前一个分型（分型确认需等待第4根K线）
                if array.size(pen_fractals) > 0
                    last_fx = array.last(pen_fractals)
                    if not last_fx.confirmed
                        last_fx.confirmed := true
                
                if array.size(pen_fractals) == 0
                    // 第一个分型
                    label lbl = na
                    if show_fractal_labels
                        lbl := label.new(
                             x = new_time, 
                             y = new_price, 
                             text = is_top ? '顶' : '底', 
                             color = PEN_COLOR, 
                             textcolor = color.white, 
                             xloc = xloc.bar_time,
                             size = size.tiny)
                    array.push(pen_fractals, Fx.new(
                         new_price, 
                         k2.high, 
                         k2.low, 
                         new_time, 
                         new_type, 
                         lbl, 
                         new_kx_index,
                         new_bar_idx,
                         false))
                else
                    lastfx = array.last(pen_fractals)
                    
                    if new_type != lastfx.type
                        // 不同类型分型，尝试构建笔
                        bool is_valid = false
                        int kx_gap = new_kx_index - lastfx.kx_index
                        
                        if pen_algo == '新笔/严格笔'
                            if new_type == 1
                                is_valid := kx_gap >= 2 and k2.low > lastfx.fx_high
                            else
                                is_valid := kx_gap >= 2 and k2.high < lastfx.fx_low
                        else
                            is_valid := kx_gap >= 2
                        
                        // 检查笔的最小K线数（加入缺口计数）
                        int effective_kx_count = kx_gap + 1 + count_gaps_between(lastfx.kx_index, new_kx_index)
                        
                        // 检查笔端点是否是极值
                        bool is_peak = check_end_is_peak(lastfx.kx_index, new_kx_index, new_type == 1)
                        
                        if is_valid and effective_kx_count >= min_pen_bars and is_peak
                            label lbl2 = na
                            if show_fractal_labels
                                lbl2 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time,
                                     size = size.tiny)
                            
                            // 确认上一个分型
                            lastfx.confirmed := true
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl2, 
                                 new_kx_index,
                                 new_bar_idx,
                                 false))
                            
                            // 计算笔的MACD面积
                            float pen_macd_area = calc_macd_area(lastfx.bar_idx, new_bar_idx, new_type)
                            
                            // 计算笔的属性
                            int pen_kx_count = kx_gap + 1
                            float pen_amplitude = math.abs(new_price - lastfx.price)
                            float pen_slope = pen_kx_count > 0 ? pen_amplitude / pen_kx_count : 0
                            
                            // 确认前一笔（如果存在）
                            if array.size(pens) > 0
                                prev_pen = array.last(pens)
                                prev_pen.confirmed := true
                            
                            // 画笔线
                            line_color = new_type == 1 ? PEN_UP_COLOR : PEN_DOWN_COLOR
                            pline = line.new(
                                 x1 = lastfx.time, 
                                 y1 = lastfx.price, 
                                 x2 = new_time, 
                                 y2 = new_price, 
                                 color = line_color, 
                                 width = PEN_WIDTH, 
                                 xloc = xloc.bar_time)
                            array.push(pen_lines, pline)
                            
                            // 创建笔
                            array.push(pens, Pen.new(
                                 array.size(pen_fractals) - 2, 
                                 array.size(pen_fractals) - 1, 
                                 math.max(lastfx.price, new_price), 
                                 math.min(lastfx.price, new_price), 
                                 new_type,  // direction: 1=向上, -1=向下
                                 lastfx.time, 
                                 new_time,
                                 lastfx.bar_idx,
                                 new_bar_idx,
                                 pen_macd_area,
                                 false,  // 新笔未确认
                                 pen_kx_count,
                                 pen_amplitude,
                                 pen_slope))
                            
                            // 构建线段（如果启用）
                            if segment_enabled
                                build_segments()

                            // 重新计算所有中枢和买卖点
                            check_and_build_centers()
                    else
                        // 同类型分型，检查是否需要延伸
                        bool should_replace = false
                        if new_type == 1
                            should_replace := new_price > lastfx.price
                        else
                            should_replace := new_price < lastfx.price
                        
                        if should_replace
                            // 删除旧分型标签
                            if not na(lastfx.label_id)
                                label.delete(lastfx.label_id)
                            
                            // 删除对应的笔线和笔
                            if array.size(pen_lines) > 0
                                line.delete(array.pop(pen_lines))
                            if array.size(pens) > 0
                                array.pop(pens)
                                cleanup_after_pen_change()
                            
                            array.pop(pen_fractals)
                            
                            // 创建新分型
                            label lbl3 = na
                            if show_fractal_labels
                                lbl3 := label.new(
                                     x = new_time, 
                                     y = new_price, 
                                     text = is_top ? '顶' : '底', 
                                     color = PEN_COLOR, 
                                     textcolor = color.white, 
                                     xloc = xloc.bar_time,
                                     size = size.tiny)
                            
                            array.push(pen_fractals, Fx.new(
                                 new_price, 
                                 k2.high, 
                                 k2.low, 
                                 new_time, 
                                 new_type, 
                                 lbl3, 
                                 new_kx_index,
                                 new_bar_idx,
                                 false))
                            
                            // 重新创建笔
                            if array.size(pen_fractals) > 1
                                prevfx = array.get(pen_fractals, array.size(pen_fractals) - 2)
                                float pen_macd_area2 = calc_macd_area(prevfx.bar_idx, new_bar_idx, new_type)
                                
                                // 计算笔的属性
                                int pen_kx_count2 = new_kx_index - prevfx.kx_index + 1
                                float pen_amplitude2 = math.abs(new_price - prevfx.price)
                                float pen_slope2 = pen_kx_count2 > 0 ? pen_amplitude2 / pen_kx_count2 : 0
                                
                                line_color = new_type == 1 ? PEN_UP_COLOR : PEN_DOWN_COLOR
                                pline2 = line.new(
                                     x1 = prevfx.time, 
                                     y1 = prevfx.price, 
                                     x2 = new_time, 
                                     y2 = new_price, 
                                     color = line_color, 
                                     width = PEN_WIDTH, 
                                     xloc = xloc.bar_time)
                                array.push(pen_lines, pline2)
                                
                                array.push(pens, Pen.new(
                                     array.size(pen_fractals) - 2, 
                                     array.size(pen_fractals) - 1, 
                                     math.max(prevfx.price, new_price), 
                                     math.min(prevfx.price, new_price), 
                                     new_type, 
                                     prevfx.time, 
                                     new_time,
                                     prevfx.bar_idx,
                                     new_bar_idx,
                                     pen_macd_area2,
                                     false,
                                     pen_kx_count2,
                                     pen_amplitude2,
                                     pen_slope2))
                                
                                // 重新计算所有中枢和买卖点
                                check_and_build_centers()
        
        // 开始新的合并K线
        current_kx := Kx.new(high, low, time, -1, bar_index)

// === 处理买卖点信号 ===
if barstate.islast
    pen_count = array.size(pens)
    
    // 清理旧的交易信号
    if array.size(trade_signals) > 0
        for i = 0 to array.size(trade_signals) - 1
            sig = array.get(trade_signals, i)
            safe_delete_label(sig.label_id)
        array.clear(trade_signals)
    
    // 重置状态
    last_buy1_pen_idx := na
    last_buy1_price := na
    last_sell1_pen_idx := na
    last_sell1_price := na
    
    // 从头开始扫描所有已确认的笔
    if pen_count >= 3
        for i = 2 to pen_count - 1
            pen = array.get(pens, i)
            
            if pen.confirmed and bsp_enabled
                // 检查1买
                [buy1_triggered, new_buy1_idx, new_buy1_price, buy1_type] = check_buy1(i, last_buy1_pen_idx, last_buy1_price)
                if buy1_triggered
                    last_buy1_pen_idx := new_buy1_idx
                    last_buy1_price := new_buy1_price
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)

                    // 根据类型显示不同标签
                    string label_text = buy1_type == 101 ? "1B+" : "1B"
                    int signal_type = buy1_type == 101 ? 101 : 1
                    string reason = buy1_type == 101 ? "Type 1 Buy Enhanced" : "Type 1 Buy"

                    lb = add_trade_signal_label(end_fx.time, end_fx.price, label_text, 1)
                    array.push(trade_signals, TradeSignal.new(signal_type, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, reason, lb))

                // 检查1卖
                [sell1_triggered, new_sell1_idx, new_sell1_price, sell1_type] = check_sell1(i, last_sell1_pen_idx, last_sell1_price)
                if sell1_triggered
                    last_sell1_pen_idx := new_sell1_idx
                    last_sell1_price := new_sell1_price
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)

                    string label_text = sell1_type == -101 ? "1S+" : "1S"
                    int signal_type = sell1_type == -101 ? -101 : -1
                    string reason = sell1_type == -101 ? "Type 1 Sell Enhanced" : "Type 1 Sell"

                    lb = add_trade_signal_label(end_fx.time, end_fx.price, label_text, -1)
                    array.push(trade_signals, TradeSignal.new(signal_type, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, reason, lb))

                // 检查2买
                [buy2_triggered, buy2_type] = check_buy2(i, last_buy1_pen_idx, last_buy1_price)
                if buy2_triggered
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)

                    string label_text = buy2_type == 202 ? "2B+" : "2B"
                    int signal_type = buy2_type == 202 ? 202 : 2
                    string reason = buy2_type == 202 ? "Type 2 Buy Enhanced" : "Type 2 Buy"

                    lb = add_trade_signal_label(end_fx.time, end_fx.price, label_text, 1)
                    array.push(trade_signals, TradeSignal.new(signal_type, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, reason, lb))

                // 检查2卖
                [sell2_triggered, sell2_type] = check_sell2(i, last_sell1_pen_idx, last_sell1_price)
                if sell2_triggered
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)

                    string label_text = sell2_type == -202 ? "2S+" : "2S"
                    int signal_type = sell2_type == -202 ? -202 : -2
                    string reason = sell2_type == -202 ? "Type 2 Sell Enhanced" : "Type 2 Sell"

                    lb = add_trade_signal_label(end_fx.time, end_fx.price, label_text, -1)
                    array.push(trade_signals, TradeSignal.new(signal_type, 1, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, reason, lb))
                
                // 检查3买
                if check_buy3(i)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "3B", 1)
                    array.push(trade_signals, TradeSignal.new(3, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
                
                // 检查3卖
                if check_sell3(i)
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    lb = add_trade_signal_label(end_fx.time, end_fx.price, "3S", -1)
                    array.push(trade_signals, TradeSignal.new(-3, end_fx.bar_idx, end_fx.time, end_fx.price, i, na, lb))
    
    // 显示背驰信号
    if show_divergence_signals and pen_count >= 3
        for i = math.max(2, pen_count - 5) to pen_count - 1
            pen = array.get(pens, i)
            if pen.confirmed
                [has_div, area_cur, area_prev] = detect_bi_divergence(i)
                if has_div
                    end_fx = array.get(pen_fractals, pen.end_fx_idx)
                    div_text = pen.direction == 1 ? "顶背驰" : "底背驰"
                    div_color = pen.direction == 1 ? color.red : color.green
                    
                    // 检查是否已有该背驰的1买/1卖标签
                    bool label_exists = false
                    for j = 0 to array.size(trade_signals) - 1
                        sig = array.get(trade_signals, j)
                        if sig.ref_pen_idx == i and (sig.type == 1 or sig.type == -1)
                            label_exists := true
                            break
                    
                    if not label_exists
                        // 显示背驰标签（独立于买卖点）
                        label.new(
                             x = end_fx.time,
                             y = pen.direction == 1 ? pen.high * 1.001 : pen.low * 0.999,
                             text = div_text,
                             color = div_color,
                             textcolor = color.white,
                             style = pen.direction == 1 ? label.style_label_down : label.style_label_up,
                             size = size.tiny,
                             xloc = xloc.bar_time)

// === 辅助图表 ===
plot(close, title = "helper", color = color.new(color.gray, 100), linewidth = 1)

// === 信息表格 (白色主题) ===
var table info_table = table.new(position.top_right, 2, 16, bgcolor = #ffffff, border_width = 1, border_color = #e0e0e0)
if barstate.islast
    // 白色主题颜色配置
    color title_bg = #f5f5f5      // 浅灰背景
    color value_bg = #ffffff      // 白色背景
    color title_text = #333333    // 深灰标题文字
    color value_text = #1976d2    // 蓝色数值
    color highlight_text = #00897b // 绿色高亮
    color warning_text = #d32f2f   // 红色警告
    color on_text = #4caf50       // 开启状态
    color off_text = #9e9e9e      // 关闭状态

    // 基础统计
    table.cell(info_table, 0, 0, "合并K线", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 0, str.tostring(array.size(kx_array)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 1, "分型数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 1, str.tostring(array.size(pen_fractals)), text_color = value_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 2, "笔数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 2, str.tostring(array.size(pens)), text_color = highlight_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 3, "线段数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 3, str.tostring(array.size(segments)), text_color = highlight_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 4, "中枢数", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 4, str.tostring(array.size(pen_centers)), text_color = highlight_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 5, "买卖点", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 5, str.tostring(array.size(trade_signals)), text_color = #f57c00, bgcolor = value_bg, text_size = size.small)

    // 算法设置
    table.cell(info_table, 0, 6, "笔算法", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 6, pen_algo, text_color = #7b1fa2, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 7, "中枢算法", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 7, zs_algo, text_color = #7b1fa2, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 8, "最小K线", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 8, str.tostring(min_pen_bars), text_color = value_text, bgcolor = value_bg, text_size = size.small)

    // 功能开关
    table.cell(info_table, 0, 9, "线段", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 9, segment_enabled ? "✓" : "✗", text_color = segment_enabled ? on_text : off_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 10, "缺口算K", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 10, gap_as_kl ? "✓" : "✗", text_color = gap_as_kl ? on_text : off_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 11, "端点极值", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 11, bi_end_is_peak ? "✓" : "✗", text_color = bi_end_is_peak ? on_text : off_text, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 12, "买卖点类型", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 12, bsp_types, text_color = #7b1fa2, bgcolor = value_bg, text_size = size.small)
    table.cell(info_table, 0, 13, "严格3类", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 13, bsp_strict_3 ? "✓" : "✗", text_color = bsp_strict_3 ? on_text : off_text, bgcolor = value_bg, text_size = size.small)

    // 扩展中枢统计
    int ext_count = 0
    for i = 0 to array.size(pen_centers) - 1
        c = array.get(pen_centers, i)
        if c.extended
            ext_count := ext_count + 1
    table.cell(info_table, 0, 14, "扩展中枢", text_color = title_text, bgcolor = title_bg, text_size = size.small)
    table.cell(info_table, 1, 14, str.tostring(ext_count), text_color = ext_count > 0 ? warning_text : value_text, bgcolor = value_bg, text_size = size.small)

    // 最新信号
    if array.size(trade_signals) > 0
        latest_sig = array.get(trade_signals, array.size(trade_signals) - 1)
        string sig_name = ""
        if latest_sig.type == 1 or latest_sig.type == 101
            sig_name := latest_sig.type == 101 ? "1B+" : "1B"
        else if latest_sig.type == -1 or latest_sig.type == -101
            sig_name := latest_sig.type == -101 ? "1S+" : "1S"
        else if latest_sig.type == 2 or latest_sig.type == 202
            sig_name := latest_sig.type == 202 ? "2B+" : "2B"
        else if latest_sig.type == -2 or latest_sig.type == -202
            sig_name := latest_sig.type == -202 ? "2S+" : "2S"
        else if latest_sig.type == 3
            sig_name := "3B"
        else if latest_sig.type == -3
            sig_name := "3S"

        table.cell(info_table, 0, 15, "最新信号", text_color = title_text, bgcolor = title_bg, text_size = size.small)
        table.cell(info_table, 1, 15, sig_name, text_color = latest_sig.type > 0 ? on_text : warning_text, bgcolor = value_bg, text_size = size.small)

// === 最终绘制管理 ===
// 按优先级管理所有绘图对象
if barstate.islast
    draw_by_priority()
